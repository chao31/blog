<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[package.json和package-lock.json的区别]]></title>
    <url>%2F2021%2F05%2F11%2Fnode%2Fpackage-json%E5%92%8Cpackage-lock-json%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[package.jsonpackage.json文件记录项目中所需要的所有模块 当你执行 npm i时，nodeJS会从你的package.json中读取所有的dependencies信息，package.json文件只记录你通过npm install方式安装的模块信息，而这些模块所依赖的其他子模块的信息不会记录。 package-lock.jsonpackage-lock.json文件锁定所有模块的版本号(包括主模块和所有依赖子模块) package.json文件只能锁定大版本，即版本号的第一位，不能锁定后面的小版本，你每次npm install时候拉取的该大版本下面最新的版本。所以为了稳定性考虑我们不能随意升级依赖包，而package-lock.json就是来解决包锁定不升级问题的。 从npm 5.x开始，项目中采用package-lock.json的方式来锁定依赖的方式来排除自动升级问题，原则上不允许删除以及不允许放入到.gitignore与.npmignore中。 为什么会有lock呢？“锁定依赖”。小王做一个项目，里边用到了node-sass，package.json文件里会有引用：“node-sass”: “^4.9.3”，假设4.9.3是最新版，发版之后，node-sass更新到4.9.4，这时，小张需要修改小王的项目，拉取代码，install，这时，小张拉取的项目的node-sass的版本会自动更新到大版本下的最新版4.9.4，可能这个版本会影响我们之前的功能，就有问题了。这时，lock文件就出现了，npm 5以上install都是走的lock文件版本，只要不是手动更新组件版本，都是不会自动更新依赖的，这就保证了应用程序依赖之间的关系是一致的，兼容的。 升级package-lock.json如果要升级package-lock.json里面的库包，怎么操作呢？123npm install packageName // 或 npm install packageName@x.x.x ^和~的区别这里举个例子：12345"dependencies": &#123; "classnames": "2.2.5", // 表示安装2.2.5的版本 "antd": "^3.1.4", // 表示安装3.1.4及以上的版本，但是不安装4.0.0 "babel-plugin-import": "~1.1.0", // "~1.1.0",表示安装1.1.x的最新版本（不低于1.1.0），但是不安装1.2.x&#125;, 指定版本：比如”classnames”: “2.2.5”，表示安装2.2.5的版本 波浪号~+指定版本：比如 “babel-plugin-import”: “~1.1.0”,表示安装1.1.x的最新版本（不低于1.1.0），但是不安装1.2.x，也就是说安装时不改变大版本号和次要版本号 ^+指定版本：比如 “antd”: “^3.1.4”,，表示安装3.1.4及以上的版本，但是不安装4.0.0，也就是说安装时不改变大版本号。 大多数情况这种向新兼容依赖下载最新库包的时候都没有问题，可是因为npm是开源世界，各库包的版本语义可能并不相同，有的库包开发者并不遵守严格这一原则：相同大版本号的同一个库包，其接口符合兼容要求。这时候用户就很头疼了：在完全相同的一个nodejs的代码库，在不同时间或者不同npm下载源之下，下到的各依赖库包版本可能有所不同，因此其依赖库包行为特征也不同有时候甚至完全不兼容。 因此npm最新的版本就开始提供自动生成package-lock.json功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue模板编译器原理]]></title>
    <url>%2F2020%2F12%2F14%2Fnode%2FVue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考： Vue模板编译原理 Vue源码学习之模板编译器原理 HTMLParser 的实现和使用]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git rebase和git merge的区别]]></title>
    <url>%2F2020%2F11%2F28%2Fgit%2Frebase%E5%92%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[假设有个开发过程如下：12341. master分支有两个commit：C1 -&gt; C22. 我基于master切一个dev分支进行开发3. dev分支在今天下午生成了3个commit，分别在：C3(2点)-&gt; C4(3点) -&gt; C5(6点)4. 同样在今天下午，其它开发者先于我在master分支上合入了自己的分支，C6(4点) -&gt; C7(5点)，所以远程的master就变成了C1 -&gt; C2 -&gt; C6(4点) -&gt; C7(5点) 如下图：15. 在7点，我想把我的dev分支合进master，有两种选择：merge和rebase 使用git merge123451. 在master上，执行`git merge dev`2. git会找出master和dev的最近共同祖先commit点，即分叉点C23. 然后进行合并，将dev最后1次的commit（C5）和master最后一次commit（C7）合并后生成一个新的commit（C8），有冲突的话需要解决冲突4. 再将C8和C2之间的所有commit，按提交时间顺序进行排序5. 最后生成的master：C1 -&gt; C2 -&gt;C3(2点)-&gt; C4(3点) -&gt; C6(4点) -&gt; C7(5点) -&gt; C5(6点) -C8(7点) 使用git rebase12341. 在dev分支上，执行`git rebase origin/master`，push到dev远程后，再去master分支，执行`git merge dev`2. 执行rebase时，git会找出master和dev的最近共同祖先commit点，即分叉点C23. 然后将dev分支上，C2到最后一次commit(C5)之间的所有commit截取，移接到master的最后一次commit(C7)后面，但截取的这一段(C3~C5的commit的hash值会变成新的，也就是变成了C3&apos;~C5&apos;)4. dev rebase了 master后，就变成了C1 -&gt; C2 -&gt; C6 -&gt; C7 -&gt; C3&apos; -&gt; C4&apos; -&gt; C5&apos; merge和rebase的区别 git merge 操作合并分支会让两个分支的每一次提交都按照提交时间（并不是push时间）排序，并且会将两个分支的最新一次commit点进行合并成一个新的commit，最终的分支树呈现菱形 git rebase操作实际上是将当前执行rebase分支的所有基于原分支提交点之后的commit打散成一个一个的patch，并重新生成一个新的commit hash值，再次基于原分支目前最新的commit点上进行提交，并不根据两个分支上实际的每次提交的时间点排序，rebase完成后，切到基分支进行合并另一个分支时也不会生成一个新的commit点，最终的分支树呈现线性]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[merge--no-ff和--ff和--squash的区别]]></title>
    <url>%2F2020%2F11%2F28%2Fgit%2Fmerge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一张图来告诉你–no-ff和–ff git merge 我们平常什么都不加的时候，则使用默认的 –ff ， 即 fast-forward 方式 fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit git merge –no-ff1指的是强行关闭fast-forward方式,保留分支的commit历史 git merge –squash 是用来把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，那么我们合并的时候不希望把这些历史commit带过来，于是使用 动图来告诉几种合并的区别 举个例子 在master分支上，执行git merge hotfix然后看到了Fast-forward 的字样，hotfix通过–ff的方式合进了master，如下：仅仅是master指针指向了这个提交C4。这样是一种比较快的合并方式，轻量级，简单。这个时候，我们往往会删掉hotfix分支，因为它的历史作用已经结束，这个时候，我们的iss53这个功能又向前开发，进行了一次提交，到了C5，那么变成了这样：然后，我们要把iss53 这个分支合并回master，因为有分叉，两个版本的内容要进行合并,是不能用Fast-forward（只有在没有需要合并内容的时候，会有这个fast-forward 方式的提交） ，这时用的就是–no-ff的效果，并生成了一个新的commit号如果我们对第一次合并，使用了–no-ff参数，那么也会产生这样的结果，生成一个新的提交，实际上等于是对C4 进行一次复制，创建一个新的commit，这就是–no-ff的作用。 参考:“git merge”和”git merge–no ff”有什么区别？Git：git-merge的–ff和–no-ff]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[glob.sync]]></title>
    <url>%2F2020%2F11%2F10%2Fnode%2Fglob-sync%2F</url>
    <content type="text"><![CDATA[异步匹配和同步匹配1234// 异步匹配glob(pattern, [options], cb)// 同步匹配glob.sync(pattern, [options])]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue双向绑定原理]]></title>
    <url>%2F2020%2F11%2F08%2Fvue%2Fvue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文的双向绑定是简版的vue实现方式，不包含虚拟dom的实现等原理图：实现：我们要实现的是将如下代码，最终渲染成dom节点1234&lt;div id="app"&gt; &lt;input type="text" v-model="text"&gt; &#123;&#123; text &#125;&#125;&lt;/div&gt; 123456var vm = new Vue(&#123; el: 'app', data: &#123; text: 'hello world' &#125;&#125;) 1.Vue构造函数的实现可以通过如下3大步来完成dom的渲染： 添加监听器 遍历dom，编译模板 编译完成后，将dom插入到根节点12345678910111213function Vue (options) &#123; this.data = options.data; var data = this.data; // 1.添加监听器 observe(data, this); var id = options.el; // 2.遍历dom，编译模板 var dom = nodeToFragment(document.getElementById(id), this); // 3.编译完成后，将 dom 插入到根节点 document.getElementById(id).appendChild(dom); &#125; 2.使用observe，监听dataobserve方法会枚举每一个data，利用Object.defineProperty将data中的数据全部转换成getter/setter，当有新值赋给data，就会触发setter函数，然后通知订阅器Dep有更新1234567891011121314151617181920212223function observe (obj, vm) &#123; Object.keys(obj).forEach(function (key) &#123; defineReactive(vm, key, obj[key]); &#125;)&#125;function defineReactive (obj, key, val) &#123; var dep = new Dep(); Object.defineProperty(obj, key, &#123; get: function () &#123; // 添加订阅者 watcher 到主题对象 Dep if (Dep.target) dep.addSub(Dep.target); return val &#125;, set: function (newVal) &#123; if (newVal === val) return val = newVal; // 作为发布者发出通知 dep.notify(); &#125; &#125;);&#125; 3.订阅器Dep每个data都拥有一个订阅器Dep，Dep里面装着很多订阅者Watcher，当订阅器Dep收到data值改变的消息，就会通知所有watcher做更新1234567891011121314151617function Dep () &#123; this.subs = []&#125;Dep.prototype = &#123; // 添加订阅者 addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; // 通知每一个订阅者更新 this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125; 4.订阅者Watcherwatcher和使用该data的dom相关联，通过this可以访问该dom节点，所以可以通过watcher修改dom的文本属性，如，input组件:this.value = newData, 文本组件this.nodeValue = newData;当订阅器Dep收到data变化，就会通知里面的每一个watch改变dom值 123456789101112131415161718192021222324252627function Watcher (vm, node, name, nodeType) &#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.nodeType = nodeType; this.update(); Dep.target = null;&#125;Watcher.prototype = &#123; update: function () &#123; this.get(); // 更新&#123;&#123;&#125;&#125; if (this.nodeType == 'text') &#123; this.node.nodeValue = this.value; &#125; // 更新v-model if (this.nodeType == 'input') &#123; this.node.value = this.value; &#125; &#125;, // 获取 data 中的属性值 get: function () &#123; this.value = this.vm[this.name]; // 触发相应属性的 get &#125;&#125; 4.模板解析器Compile遍历所有dom，分别处理有v-model属性的元素节点和双花括号的文本节点： 将data值赋值给元素节点，如input赋值 替换文本节点的双花括号 为元素节点如input添加change事件，当value值改变时，更新被关联的data(此时双向绑定之一的view--&gt;model已完成)12345678910111213141516171819202122232425262728293031323334353637383940414243444546function nodeToFragment (node, vm) &#123; var flag = document.createDocumentFragment(); var child; // 许多同学反应看不懂这一段，这里有必要解释一下 // 首先，所有表达式必然会返回一个值，赋值表达式亦不例外 // 理解了上面这一点，就能理解 while (child = node.firstChild) 这种用法 // 其次，appendChild 方法有个隐蔽的地方，就是调用以后 child 会从原来 DOM 中移除 // 所以，第二次循环时，node.firstChild 已经不再是之前的第一个子元素了 while (child = node.firstChild) &#123; compile(child, vm); flag.appendChild(child); // 将子节点劫持到文档片段中 &#125; return flag&#125;function compile (node, vm) &#123; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; // 节点类型为元素 if (node.nodeType === 1) &#123; var attr = node.attributes; // 解析属性 for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName == 'v-model') &#123; var name = attr[i].nodeValue; // 获取 v-model 绑定的属性名 node.addEventListener('input', function (e) &#123; // 给相应的 data 属性赋值，进而触发该属性的 set 方法 vm[name] = e.target.value; &#125;); node.value = vm[name]; // 将 data 的值赋给该 node node.removeAttribute('v-model'); &#125; &#125;; new Watcher(vm, node, name, 'input'); &#125; // 节点类型为 text if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; var name = RegExp.$1; // 获取匹配到的字符串 name = name.trim(); new Watcher(vm, node, name, 'text'); &#125; &#125;&#125; 附上一副官网流程图：]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue文档纪要]]></title>
    <url>%2F2020%2F10%2F20%2Fvue%2Fvue%E6%96%87%E6%A1%A3%E7%BA%AA%E8%A6%81%2F</url>
    <content type="text"><![CDATA[计算属性和侦听器计算属性计算属性的setter计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 现在再运行 vm.fullName = &#39;John Doe&#39; 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新 列表渲染用v-for把一个数组对应为一组元素1234567891011this.items = [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125;];&lt;li v-for="(item, index) in items"&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;&lt;/li&gt;// 渲染结果：// 0 - Foo,// 1 - Bar 在v-for里使用对象12345678910111213this.object = &#123; title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10'&#125;&lt;div v-for="(value, name, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;// 渲染结果// 1.title: 'How to do lists in Vue',// 2.author: 'Jane Doe',// 3.publishedAt: '2016-04-10' 深入了解组件组件注册组件名大小写我们强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)1Vue.component('my-component-name', &#123; /* ... */ &#125;) 自定义事件事件名不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：123456// 没有效果 &lt;my-component v-on:my-event="doSomething"&gt;&lt;/my-component&gt;this.$emit('myEvent');&lt;blog-post post-title="hello!"&gt;&lt;/blog-post&gt;props: ['postTitle'], 内在深入响应式原理检测变化的注意事项对于对象响应式与非响应式：12345678910var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应式的vm.b = 2// `vm.b` 是非响应式的 给对象添加单个新属性：用$set1this.$set(this.someObject,'b',2) 给对象添加多个新属性：直接Object.assign()不会触发响应，需要原对象与要混合进去的对象的 property 一起创建一个新的对象12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 对于数组Vue 不能检测以下数组的变动：1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue2.当你修改数组的长度时，例如：vm.items.length = newLength 但$set和数组的splice、shift等方法可以触发：12Vue.set(vm.items, indexOfItem, newValue);vm.items.splice(indexOfItem, 1, newValue); 异步更新队列nextTick：将回调延迟到下次 DOM 更新循环之后执行，下面是理解nextTick的很好的例子：1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // false,因为dom未更新Vue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true，因为dom已更新&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法好文章]]></title>
    <url>%2F2020%2F10%2F12%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F%E7%AE%97%E6%B3%95%E5%A5%BD%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.JavaScript 数据结构与算法之美 - 十大经典排序算法汇总2.前端动画演绎排序算法3.JavaScript 数据结构与算法之美 - 时间和空间复杂度]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pace.js原理解析]]></title>
    <url>%2F2020%2F08%2F08%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2Fpace-js%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.看源码先从init()入手2.init()后，执行了Pace.start()方法3.Pace.go performance.now]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看了必懂的Promise源码分析]]></title>
    <url>%2F2020%2F04%2F27%2FPromise%2F%E7%9C%8B%E4%BA%86%E5%BF%85%E6%87%82%E7%9A%84Promise%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目1.123456789const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve() console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4) 题目2.12345678910111213141516const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success') &#125;, 1000)&#125;)const promise2 = promise1.then(() =&gt; &#123; throw new Error('error!!!')&#125;)console.log('promise1', promise1)console.log('promise2', promise2)setTimeout(() =&gt; &#123; console.log('promise1', promise1) console.log('promise2', promise2)&#125;, 2000) 题目3.12345678910111213const promise = new Promise((resolve, reject) =&gt; &#123; resolve('success1') reject('error') resolve('success2')&#125;)promise .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;) 题目4.1234567891011Promise.resolve(1) .then((res) =&gt; &#123; console.log(res) return 2 &#125;) .catch((err) =&gt; &#123; return 3 &#125;) .then((res) =&gt; &#123; console.log(res) &#125;) 题目5.1234567891011121314const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('once') resolve('success') &#125;, 1000)&#125;)const start = Date.now()promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;)promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;) 题目6.12345678910Promise.resolve() .then(() =&gt; &#123; return new Error('error!!!') &#125;) .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;) 题目7.12345const promise = Promise.resolve() .then(() =&gt; &#123; return promise &#125;)promise.catch(console.error) 题目8.1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 题目9.123456789Promise.resolve() .then(function success (res) &#123; throw new Error('error') &#125;, function fail1 (e) &#123; console.error('fail1: ', e) &#125;) .catch(function fail2 (e) &#123; console.error('fail2: ', e) &#125;)]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie篇]]></title>
    <url>%2F2019%2F11%2F21%2Fhttp%2Fcookie%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是cookie? 第一次访问服务器的时候，会在响应头里面看到Set-Cookie信息（只有在首次访问服务器的时候才会在响应头中出现该信息）,如：Set-Cookie:JSESSIONID=joadjosd 浏览器会根据响应头的set-cookie信息设置浏览器的cookie并保存到浏览器本地 当再次请求的时候（非首次请求），浏览器会在请求头里将cookie发送给服务器(每次请求都是这样)，如：将上面保存的 JSESSIONID=joadjosd 发给服务器 什么是JSESSIONID？ 当用户访问服务器的时候，服务器会为每一个用户开启一个session,浏览器是怎么判断这个session到底是属于哪个用户呢？JSESSIONID的作用就体现出来了：JSESSIONID就是用来判断当前用户对应于哪个session，换句话说JSESSIONID会告诉服务器该浏览器的session保存在服务器内存的什么地方。 服务器首先检查这个浏览器的请求里是否已包含了一个session标识————称为session id，如果已包含则说明以前已经为此浏览器创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个）；如果浏览器请求不包含session id，则为此浏览器创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给浏览器保存。 保存这个session id的方式可以采用cookie，这样浏览器在下次请求中，会把包含这个session id的cookie发送给服务器。 一般这个cookie的名字都是类似于SESSIONID，JSESSIONID只是tomcat的对session id的叫法，其实就是session id，在其它的容器也许就不叫JSESSIONID了。 创建cookie123function setCookie(name,value,cookieDomain) &#123; document.cookie = name + '='+ encodeURIComponent(value) + ';domain=' + cookieDomain + ';path=/';&#125; 删除cookie1234567// 删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可function delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cookie = getCookie(name); cookie &amp;&amp; (document.cookie = name + '=' + cookie + ';expires=' + exp.toGMTString()); &#125; cookie属性 属性项 属性项介绍 NAME=VALUE 键值对，可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样 Expires 过期时间，在设置的某个时间点后该 Cookie 就会失效 Domain 生成该 Cookie 的域名，如 domain=”www.baidu.com&quot; Path 该 Cookie 是在当前的哪个路径下生成的，如 path=/wp-admin/ Secure 如果设置了这个属性，那么只会在 SSH 连接时才会回传该 Cookie 参考：1.JSESSIONID的简单说明2.cookie、session、sessionid 与jsessionid3.深入理解Cookie4.javascript cookie]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用n来管理node版本]]></title>
    <url>%2F2019%2F03%2F08%2Fnode%2F%E4%BD%BF%E7%94%A8n%E6%9D%A5%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[业务项目比较多，老项目使用的node版本比较低，为了管理多个版本的node，可以使用n工具来管理n和nvm工具一样，但比它简洁 安装n1npm install -g n 下载特定版本的node12// 会下载node/10.6.0n 10.6.0 下载稳定版本1n stable 删除特定版本1n rm 10.6.0 切换版本123456n node/6.10.2 node/6.11.0 node/9.4.0o node/10.6.0 使用特定版本来执行文件1n use 10.6.0 index.js 若安装某个版本的node失败，发生1dyld: initializer function 0x0 not in mapped image for /usr/local/bin/node 删除/usr/local/n/versions/node下的所有node版本，然后重新使用n命令安装即可。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm和npx的区别]]></title>
    <url>%2F2019%2F03%2F08%2Fnode%2Fnpm%E5%92%8Cnpx%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[npmnpm是Node.js的软件包管理器，其目标是自动化的依赖性和软件包管理 npm 允许在package.json文件里面，使用scripts字段定义脚本命令 npxnpx是执行Node软件包的工具，它从 npm5.2版本开始，就与npm捆绑在一起。如果不能用，手动安装1npm install -g npx npm与npx执行命令对比： 12345678910111213// 免去了设置路径npx eslint --init// 若使用npm./node_modules/bin/eslint --init// 或者在package.json设置好scripts脚本 //&#123;// "scripts": &#123;// "eslint":"eslint --init"// &#125;//&#125; npm run eslint npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在 默认情况下，首先检查路径中是否存在要执行的包（即在项目中）； 如果存在，它将执行； 若不存在，意味着尚未安装该软件包，npx将安装其最新版本，然后执行它； 只执行，不安装(若未安装，会报错)1npx some-package --no-install]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你想知道的BFC]]></title>
    <url>%2F2018%2F11%2F25%2Fcss%2F%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84BFC%2F</url>
    <content type="text"></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入——call、apply和bind的底层实现]]></title>
    <url>%2F2018%2F06%2F16%2F%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%2Fcall-apply-bind%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[call、apply和bind的区别 三者都是this的绑定，第一个参数都需要传入要绑定的this call和apply的区别是后面的参数，call是一个一个传入，而apply是通过一个数组传入 bind会返回一个函数，在需要的地方执行该函数；而call、apply会立即执行 call的Polyfill函数都可以调用 call，说明 call 是函数原型上的方法，所有的实例都可以调用。即: Function.prototype.call call的实现需要注意以下几点： 在 call 方法中获取调用call()函数 第一个参数可以不传或传null，此时this默认指向 window 从第二个参数起，可以向call传入不定长的参数 传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj;因此我们可以这样调用函数 context.fn(…args),即在上下文对象添加要执行的fn 执行完毕，delete添加的fn属性 Polyfill:123456789101112131415Function.prototype.call2 = function() &#123; // 初始化绑定的this对象(context)和参数args let [context, ...args] = [...arguments]; // args没传或传null，绑定window !context &amp;&amp; (context = window); // 将要执行的函数，绑定到context的fn属性上 context.fn = this; // 执行fn let result = context.fn(...args); // 删除多余添加的属性 delete context.fn; // 返回结果 return result;&#125; 测试一下：123456789101112131415// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call2(foo, 'kevin', 18);// kevin// 18// 1 bind2的测试没问题了，就可以把它放进prototype.bind，Polyfill的写法：123456if (!Function.prototype.bind)(function()&#123; Function.prototype.bind = function() &#123; ... &#125;&#125;)(); apply的Polyfillapply与call的实现，只有取参数的方式不同123456789Function.prototype.apply2 = function(context, args) &#123; !context &amp;&amp; (context = window); context.fn = this; let result = args ? context.fn(...args) : context.fn(); delete context.fn; return result;&#125; 测试一下：123456789101112131415// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.apply2(foo, ['kevin', 18]); // kevin// 18// 1 bind的Polyfillbind和call的区别就是，返回一个函数，在这个函数里执行fn123456789101112Function.prototype.bind2 = function() &#123; let [context, ...args] = [...arguments]; !context &amp;&amp; (context = window); context.fn = this; return function() &#123; let result = context.fn(...args); delete context.fn; return result; &#125;;&#125; 测试一下：12345678910111213141516// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;var func = bar.bind2(foo, 'kevin', 18); func();// kevin// 18// 1 也可以参考MDN的Polyfill]]></content>
      <categories>
        <category>前端深入</category>
      </categories>
      <tags>
        <tag>前端深入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git reset、--soft、--hard的区别]]></title>
    <url>%2F2018%2F06%2F13%2Fgit%2Fgit%E7%9A%84reset%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1git reset [--soft | --mixed | --hard] 为了简单，不用工作区和暂存区描述，用红色文件和绿色文件描述 git resetgit reset 不加参数，默认是–mixed git会回到指定的commit，并将两个commit之间的所有diff保留下来（红色文件） 利用这个特性，在合master前，feature分支的commit太多，希望合成一个12345// 回到最初的commitgit reset xxxxx// 重新提一个commitgit add -Agit commit -m '新功能xxx' ☑️ Squash commits when merge request is accepted.其实提MR时，勾选这个，就能合并所有的commit git reset –hardgit 会回到指定的commit，但两个commit之间的所有diff都被删除，干干净净的回到指定commit（如果执行这个命令之前就有被修改的红色文件，执行之后也会被删除） git reset –softgit会回到指定的commit，并将两个commit之间的所有diff保留下来，但不会变成红色文件，而是变成绿色文件（执行命令之前的红色文件修改，依然保留下来为红色）]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存机制]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%BC%93%E5%AD%98%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[HTTP缓存机制 当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源： 200 from memory cache不访问服务器，直接读缓存，从内存中读取缓存,此时的数据时缓存到内存中的，当页面被关闭以后，数据将不存在。 200 from disk cache不访问服务器，直接读缓存，从磁盘中读取缓存，当页面或浏览器关闭后，数据还是存在。 304 (Not Modified) 缓存过期，但Last-Modified、Etag验证资源有效，服务器返回304 缓存需要强制验证，确定资源有效后，服务器返回304，如：Cache-Control：no-cach（这个设置规定缓存前必须先确定有效性） 具体描述： 本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器； 协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源； 缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本地缓存中没有找到资源)，服务器则返回该资源的数据，并且返回200 协商缓存阶段Last-Modified &amp; if-modified-since Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。last-modified是WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间。 ETag &amp; If-None-Match ETag与If-None-Match是一对报文，属于http 1.1。ETag是一个文件的唯一标志符,就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化,如果请求资源的ETag与服务器的不一致，则表示该资源已经被修改过来，需要发最新的内容给浏览器。 Etag/lastModified过程如下： 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个Last-Modified/ETag。 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。 注意：通过If-Modified-Since和If-Match判断资源是否修改，如未修改则返回304，发生了一次请求，但请求内容长度为0，节省了带宽，如果有多台负载均衡的服务器，不同服务器计算出的Etag可能不同，这样就会造成资源的重复加载。 Etag主要为了解决Last-Modified无法解决的一些问题： 一些文件如果改变后，又改回来了，Last-Modified会认为文件修改过，但其实它是没有变化的，Etag就不会判定它变化了 If-Modified-Since能检查到文件的变化是秒级别的，但如果一个文件1秒内变化了好几次，If-Modified-Since就检测不出来，这时需要Etag检测 某些服务器不能精确的得到文件的最后修改时间 本地缓存阶段Expires和Cache-Control是需要在服务器端配置的 Expires 指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires。如果expires到期需要重新请求。 Cache-Control Cache-Control:这个是http 1.1中为了弥补 Expires 缺陷新加入的，下面是常用的值： no-cache：强制浏览器在使用cache之前，先提交一个http请求到源服务器进行确认资源是否有效，防止从缓存中获取的是无效的资源。虽然http请求并未减少，但返回的是一个空的请求体，这样相当于减少了一个响应体。 no-store：no-store规定了浏览器不缓存任何缓存，而no-cache只是不缓存无效（这里是无效不是过期）的资源。如下图：资源Expires已失效，也设置了no-cach,但浏览器还是缓存了过期的资源(304可以证明已缓存)，因为服务器判断了If-Modified-Since，资源是没有改动过的，所以返回了304。 max-age:指定多少秒后缓存过期，如Cache-Control: max-age=3600, must-revalidate（3600秒后过期） must-revalidate: 强制浏览器严格遵守你设置的cache规则。 proxy-revalidate: 强制proxy严格遵守你设置的cache规则。 参考： 缓存策略 详解浏览器缓存机制与Apache设置缓存 由memoryCache和diskCache产生的浏览器缓存机制的思考]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack使用指南]]></title>
    <url>%2F2018%2F05%2F07%2Fwebpack%2Fwebpack%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[创建package.json1npm init 在项目的根目录中执行这个命令，它会自动创建 package.json文件，然后终端会问诸如项目名称，项目描述，作者等信息，可默认回车 安装Webpack依赖包1npm install --save-dev webpack 这时package.json里会增加两个属性：description和devDependencies –save-dev 与 –save的区别 npm install X:会把X包安装到node_modules目录中不会修改package.json,之后运行npm install命令时，不会自动安装X npm install --save-dev *:使用此命令安装，会将依赖安装到devDependencies目录下，该目录下都是开发时需要的依赖,如npm install --save-dev gulp-uglify，安装了js的压缩包gulp-uglify，而压缩插件只在开发时使用，项目发布后不需要 npm install --save *:会将依赖安装到description目录下，该目录下都是发布后也需要的依赖，如vue这样的框架，项目发布后依然需要 简单的demo src/index.js 1document.getElementById('title').innerHTML = 'hello webpack'; dist/index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="title"&gt;&lt;/div&gt;&lt;script src="./js/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789// var path = require('path');module.exports = &#123; entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', // path: path.resolve(__dirname, 'dist'), filename: 'js/bundle.js' &#125;&#125; 注：__dirname是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 执行webpack，/dist/目录下会打包生成js/bundle.js,同时出现警告： 警告提示mode没有定义，这是 webpack 4x 引入的，有两个值，development 和 production，默认是production，可以用下面这两种方式指定： 执行webpack --mode development，而不是执行webpack 在webpack.config.js中指定mode属性，如：12345678module.exports = &#123; mode: 'development', entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', filename: 'js/bundle.js' &#125;&#125; 配置命令通过在package.json中配置script，如：123"scripts": &#123; "build": "webpack --mode development"&#125; 就可以用命令 npm run build 替代 webpack --mode development Source MapsSource Maps可以使调试更方便，当定位错误时，可以使编译文件与源文件一一对应，通过配置webpack.config.js中的devtool属性12345678module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', filename: 'js/bundle.js' &#125;&#125; devtool有4个值，优缺点如下： devtool选项 配置结果 source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度 cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便 eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项 cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点 使用webpack构建本地服务器Webpack提供了一个可选的本地开发服务器，可以让浏览器监听你的代码修改，并自动刷新显示修改后的结果这个本地服务器基于node.js构建，它是一个单独的组件，在webpack.config.js中配置前，需要单独安装 npm install --save-dev webpack-dev-server 然后配置devServer属性： 12345678910111213module.exports = &#123; entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', filename: 'js/bundle.js' &#125;, devServer: &#123; contentBase: "./dist",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true,//实时刷新 port: 8080//设置默认监听端口，如果省略，默认为”8080“ &#125;&#125; 在package.json中的scripts对象中添加如下命令，用以开启本地服务器： 123"scripts": &#123; "server": "webpack-dev-server --open"&#125; 在终端中输入 npm run server即可在本地的8080端口查看结果]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https原理]]></title>
    <url>%2F2018%2F05%2F03%2Fhttp%2Fhttps%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[TCP/IP协议簇 TCP/IP协议簇是协议的集合，包含上图等协议，http协议就是它的一个子集；TCP/IP协议并不完全符合OSI的七层参考模型，它采用了4层的层级结构，如下图。 http协议处于应用层，当客户端发送http请求，为了便于传输，传输层（TCP协议）将应用层的http报文进行切割，并在各个报文上打上标记序号及端口号，转发给网络层（IP协议），网络层增加目的地——MAC地址后转发给链路层，这样发送网络的请求准备就齐全了；服务器端在链路层接收到数据，按顺序往上发送，一直到应用层，这样才算真正接收到http请求。 发送端在曾与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息，反之，服务器端在接收时会一层一层的去掉首部信息，这种把数据信息包装起来的方法叫做封装。 为了确认数据送到目标处，TCP协议采用了三次握手的策略，握手的过程中使用了TCP标志（flag）——SYN和ACK：发送端首先发送一个带有SYN的标志给对方，接收端收到后，发送一个SYN/ACK标志的数据包，表示确认收到，最后，发送端再发送一个ACK标志的数据包，代表“握手”结束。 http协议 HTTP协议（HyperText Transfer Protocol，超文本传输协议）：是客户端与Web服务器之间的应用层通信协议。 http协议的不足 通信使用明文（不加密），内容有可能被窃听 不验证通信双方的身份，有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 https协议 HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。 如上图，HTTPS 相比 HTTP 多了一层 SSL/TLS，位于应用层与TCP协议之间。 http请求劫持HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下： 加密算法 对称加密：加密和解密都是使用的同一个密钥——对称密钥。 非对称加密: 加密和解密使用不同的密钥——公钥、私钥，公钥和算法都是公开的，私钥是保密的，用公钥加密，就可以用私钥解密，反之亦然；但公钥是公开的（黑客也有公钥），如果私钥加密的信息被黑客截获，黑客同样可以使用公钥进行解密，获取其中的内容，所以使用非对称加密，通信双方通常有两套私钥和公钥，发消息的一方使用对方的公钥进行加密，接收消息的一方使用自己的私钥解密（所以私钥可以认为是个人身份的证明）；非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 消息摘要：消息摘要是哈希算法的一种，可以将消息哈希转换成一个固定长度的值唯一的字符串。值唯一的意思是不同的消息转换的摘要是不同的，并且能够确保唯一。该过程不可逆，即不能通过摘要反推明文（似乎SHA1已经可以被破解了，SHA2还没有。一般认为不可破解，或者破解需要耗费太多时间，性价比低）。 数字签名： 签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过;hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改,举例如下：假设现在有通信双方A和B，两者之间使用两套非对称加密机制,现在A向B发消息:那么，如果在发送过程中，有人修改了里面密文消息，B拿到的密文，解密之后得到明文，并非A所发送的，信息不正确。要解决两个问题：1. A的身份认证 2. A发送的消息完整性 那么就要用到上面所讲的基础知识。数字签名的过程如下图：简单解释：A：将明文进行摘要运算后得到摘要（消息完整性），再将摘要用A的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给B。B：收到A的消息后，先将密文用自己的私钥解密，得到明文。将数字签名用A的公钥进行解密后，得到正确的摘要（解密成功说明A的身份被认证了）。对明文进行摘要运算，得到实际收到的摘要，将两份摘要进行对比，如果一致，说明消息没有被篡改（消息完整性）。疑问：摘要使用A的私钥加密，如果被拥有A的公钥的第三者截获，不就可以获取到摘要了么，会不会对安全造成威胁？答：不会，因为摘要是不可逆推出原文的。 HTTP 向 HTTPS 演化使用对称加密若对传输的信息加密,这样即使黑客截获，也无法破解此种方式属于对称加密，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是： 因为双方都要有密钥，所以若是客户端有了一个密钥，如何安全地给服务器也传送一把 客户端、服务器数量多，安全级别也不同，密钥极易泄露 所以试一试非对称加密 使用非对称加密如上图所示，它只使用了一套公钥和私钥，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，同理，服务器使用私钥加密，客户端可以使用公钥解密，所以缺点就出来了：公钥是公开的（也就是黑客也会有公钥），所以第4步是不安全的，如果私钥加密的信息被黑客截获，黑客同样可以使用公钥进行解密，获取其中的内容。 但第3步是安全的，所以可以利用非对称加密的第3步，再结合对称加密的方式，一起实现加密。 对称与非对称加密的结合 第3步使用的是非对称加密，客户端用公钥加密，将对称加密算法和对称密钥传输给了服务器 服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥，这时客户端和服务器端都有了对称密钥 从第4步开始，双方都使用对称加密进行通信 这种方式的问题： 客户端如何获得公钥 如何确认服务器是真实的而不是黑客 所以有了数字证书，服务器需要申购SSL证书 SSL证书校验如上图所示，在第2步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有： 证书的发布机构CA 证书的有效期 公钥 证书所有者 签名… 客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下： 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验 浏览器的”证书管理器”，有”受信任的根证书颁发机构”列表,客户端会根据这张列表，比对服务器发来的证书中的颁发者CA，校验证书是否为合法机构颁发 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。 如果找到，那么浏览器就会从操作系统中取出颁发者CA的公钥，然后对服务器发来的证书里面的签名进行解密 浏览器使用相同的摘要算法计算出服务器发来的证书的摘要，将这个计算的摘要与证书签名解密出的摘要做对比 对比结果一致，则证明服务器发来的证书合法，没有被冒充 此时浏览器就可以读取证书中的公钥，用于后续加密了 所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成所以相比HTTP，HTTPS 传输更加安全 所有信息都是加密传播，黑客无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 总结综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。HTTPS 缺点： SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐 HTTPS 降低用户访问速度（多次握手） 网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转） HTTPS 涉及到的安全算法会消耗 CPU 本文转载自 HTTPS 加密算法原理详解，增加了少量自己的归纳、理解参考： 《图解HTTP协议》 数字签名原理简介]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊:变量,作用域与内存]]></title>
    <url>%2F2017%2F06%2F23%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F%E8%81%8A%E4%B8%80%E8%81%8A-%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[数据类型js数据类型分两种： 基本数据类型：Undefined、 Null、 String、 Boolean、 Number、 String 和 Symbol(ES6新增) 复杂数据类型：Object 区别：内存的分配不同 基本数据类型存储在栈中 复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址 区分数据类型的方法： typeof：可以确定值是否是基本数据类型 instanceof：可以确定值是否是引用数据类型用 12typeof null // objectnull instanceof Object // false 区分数组和Object12// [Object, objct]、[Object, array]Object.prototype.toString.call() null是一个对象吗？ 另外尽管 typeof null === &#39;object&#39;,但null 不是一个对象，这是一个历史遗留问题，JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，null 表示为全零，所以将它错误的判断为 object 。 作用域链 内部上下文可以通过作用域链访问外部上下文的一切，但外部上下文无法访问内部上下文中的东西。找一个变量，如果在局部找到，则搜索停止；否则，继续沿着作用域链向上搜（作用域链中的对象有原型链，因此搜索也可能涉及每一个对象的原型链），这个过程一直延续到全局上下文的变量对象；若仍找不到，则未声明。 js执行上下文执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 执行上下文分全局上下文、函数上下文和块级上下文 JS执行上下文栈(后面简称执行栈)执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。 规则如下：首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。 以一段代码具体说明： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3();&#125;function fun1() &#123; fun2();&#125;fun1(); Global Execution Context (即全局执行上下文)首先入栈，过程如下：伪代码:12345678910111213141516171819202122//全局执行上下文首先入栈ECStack.push(globalContext);//执行fun1();ECStack.push(&lt;fun1&gt; functionContext);//fun1中又调用了fun2;ECStack.push(&lt;fun2&gt; functionContext);//fun2中又调用了fun3;ECStack.push(&lt;fun3&gt; functionContext);//fun3执行完毕ECStack.pop();//fun2执行完毕ECStack.pop();//fun1执行完毕ECStack.pop();//javascript继续顺序执行下面的代码，但ECStack底部始终有一个 全局上下文（globalContext）; 参考 块级作用域的概念 由最近的一对{}界定 var、let 和 const var存在变量的提升 let也存在变量的提升，但因存在“暂时性死区”，故不能在声明前使用let变量 let与var不同在于，同一作用域内let不能重复声明，let有块级作用域；let在全局作用域声明的变量不会成为window的属性 const和let基本相同，除了一点，声明时必须初始化变量，且不能修改；但可以修改const对象的属性（const a = Object.freeze({})可以冻结） js变量是松散类型，意思是可以保存任何类型的数据 内存管理优化内存的手段： 数据不再用，赋值null，释放其引用 let和const有块级作用域，有助于垃圾回收]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git常用技巧]]></title>
    <url>%2F2017%2F05%2F12%2Fgit%2Fgit%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[git push –set-upstream新建一个分支NAME后，直接执行git push到远程，是push不上去的 要么就是暴力推上去git push origin NAME, 若用下面这个建立远程关联，以后就能用git push了1git push --set-upstream origin NAME git push12// 提交本地test分支 作为 远程的master分支git push origin test:master git rebase12345678// 相当于是从远程获取最新版本到本地，不会自动mergegit fetch// 把b分支合并到当前分支git rebase b // 如：将远程的origin/master，合到本地分支git rebase origin/master 提mr时，合master有冲突1234567891011git checkout -b &lt;分支名&gt; origin/&lt;分支名&gt;git checkout mastergit pull --rebase=truegit checkout &lt;分支名&gt;# 合并mastergit merge master --no-ff# 解决冲突后，git add -Agit commit -m &lt;合并信息&gt;git push origin &lt;分支名&gt;:&lt;分支名&gt; 文件回退到指定版本12345// 会把文件变成绿色 + 红色git reset xxxx file// 对红色进行checkout恢复，就只剩绿色了，但文件已经变回指定版本了git checkout file// 若想让绿色变成红色，继续reset操作 回退到某个版本详细请看123git reset abcsdgit reset --hard abcsdgit reset --soft abcsd git reflog 回退到某个操作1234// 通过reflog找到操作的commitgit reflog// 回到那个commitgit reset 回退到上一个版本上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~1001git reset --hard HEAD^ git diff123456// 查看当前修改了啥git diff// 和某个commit做diffgit diff 276bb8f// 和某个文件做diffgit diff index.html 查看分支合并图1git log --graph 基于某个分支创建新分支12345678// 基于当前分支创建新分支devgit checkout -b dev// 基于远程分支，创建新分支git checkout -b &lt;分支名&gt; origin/&lt;分支名&gt;// 如：本地没有 develop-test，基于远程创建一个develop-testgit checkout -b develop-test origin/develop-test 分支查看本地分支：git branch 查看远程分支：git branch -a 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; git stash查看工作现场：git stash list 恢复现场但不删除stash：git stash apply 删除stash：git stash drop 恢复现场并删除stash：git stash pop]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建git服务器]]></title>
    <url>%2F2017%2F03%2F13%2Fgit%2F%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[ubuntu安装git123456// 安装sudo apt-get install git// git仓库配置git config --global user.name "Your Name"git config --global user.email "email@example.com" 在Ubuntu上创建git用户1sudo adduser git 这样在/home目录下就多了一个git目录 在git用户下创建.ssh 目录1234cd /home/gitmkdir .sshcd .sshvi authorized_keys 将本地~/.ssh 里的id_rsa.pub中的内容添加到服务器端的authorized_keys 初始化一个git仓库在opt下建一个git目录，以后git的仓库都放在这个目录12345cd /optmkdir gitchown -R git:git git //修改git目录的拥有者chmod 777 gitcd git // chown将指定文件的拥有者改为指定的用户或组chown -R 用户名:组名 文件 初始化一个project仓库，一般以.git结尾进行命名123mkdir project.git cd project.gitgit --bare init 本地进行代码推送1234567# 在 本地 的电脑上cd myprojectgit initgit add .git commit -m 'initial commit'git remote add origin git@gitserver:/opt/git/project.gitgit push origin master 若因权限问题推送失败，则可能是文件夹所有者问题12# 修改服务器project.git仓库的所有者chown -R git:git project.git node 安装 去node官网，找到对应版本链接 wget https://nodejs.org/dist/v10.15.0/node-v10.15.0-linux-x64.tar.xz mv到对应目录，如/opt/ 解压 12tar -xvf node-v10.15.0-linux-x64.tar.xzmv node-v10.15.0-linux-x64.tar.xz nodejs 确认一下nodejs下bin目录是否有node 和npm文件，如果有则执行软连接，变为全局 12ln -s /opt/nodejs/bin/npm /usr/local/bin/ ln -s /opt/nodejs/bin/node /usr/local/bin/]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础---位运算]]></title>
    <url>%2F2016%2F04%2F25%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[通过一道题来回顾下位运算两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 示例:12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 答案：1234567891011121314var hammingDistance = function(x, y) &#123; var count = 0; while(x !== 0 || y !== 0) &#123; // 1001 // 0001 // x &amp; 1,其实比较的是x的最后一位数， if((x &amp; 1) !== (y &amp; 1)) &#123; ++count; &#125; x = x &gt;&gt; 1; y = y &gt;&gt; 1; &#125; return count;&#125;; 思路其实很简单：遍历两个数值，位数不相同那么 +1 负值如何用二进制表示通过3个步骤得到： 确定绝对值的二进制表示（如-18，先确定18的二进制表示） 找到每一位数值的补数，也就是，每个0变1，1变0 给结果+1 有符号的整数有符号的整数：第32位是符号位，如0表示正，1表示负；使用剩余的31位表示数值大小。 位运算规则12345&amp; : 按二进制位进行 与运算，相同位同时为 1 时结果为 1，否则为 0| : 按二进制位进行 或运算，相同位有一个为 1 时结果为 1，否则为 0^ : 按二进制位进行 异或运算，相同位相同时结果为 0，否则为 1&gt;&gt; : 右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位用符号位来补&lt;&lt; : 左移运算是将一个二进制位的操作数按指定移动的位数向左移位，移出位被丢弃，右边的空位一律补 0 将-5右移1位123var x = -5;x &gt;&gt;= 1;// -3 发生了如下12345678910111213// 如：-5// 1.找到5000...101// 2.找补数111...010// 3.补数+1,得到-5111...011// 4.右移1位1111..101// 5.减一1111..100// 6.取反，-3（符号位跟以前一样）0000..011]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
  </entry>
</search>
