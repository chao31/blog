<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue3中双向绑定的实现]]></title>
    <url>%2F2020%2F12%2F25%2Fvue%2Fvue3%E4%B8%AD%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[vue3的双向绑定改变，用一句话来描述：vue3的双向绑定原理由Object.defineProperty改为基于ES6的Proxy代理来实现。 为什么要替换Object.defineProperty vue官网在深入响应式原理中解释，由于 JavaScript 的限制，Vue 不能检测数组和对象的变化，也就是： 对象属性的添加和删除，无法监听 数组索引和长度的变更，无法监听 vue2.x为了给每个属性添加setter/getter，会递归调用，而Proxy能劫持整个对象，相比而言更高效 Proxy和ReflectProxy可以理解为“拦截”目标对象，外界对该对象的访问都会拦截，因此可以对外界的访问进行过滤和改写。Reflect可以理解为一个方法的集合，一些明显属于语言层面的方法，被放到了Reflect上。现阶段，某些方法同时在Object和Reflect上部署，但未来一些新方法只在Reflect上部署。12345678910111213141516171819202122var obj = &#123; name: 123, arr: [1,2,3]&#125;;// target：源对象，这里是obj// key：属性，如name、arr// value: get方法，设置的新值// receiver: 返回的proxy对象，这里是pvar p = new Proxy(obj, &#123; get(target, key, receiver) &#123; console.log('get:', target, key, receiver); // 通过Reflect，调用默认get方法 return Reflect.get(target, key, receiver); &#125;, set(target, key, value, receiver) &#123; console.log('set:', target, key, value, receiver); // 通过Reflect，调用默认set方法 return Reflect.set(target, key, value, receiver) &#125;&#125;);p.name = 456;p.name; 实现在上一篇《vue双向绑定原理》的基础上，重写监听器observe，上一篇observe的实现如下：1234567891011121314151617181920212223function observe ($data, vm) &#123; Object.keys($data).forEach(function (key) &#123; defineReactive(vm, key, $data[key]); &#125;)&#125;function defineReactive (obj, key, val) &#123; var dep = new Dep(); Object.defineProperty(obj, key, &#123; get: function () &#123; // 添加订阅者 watcher 到主题对象 Dep if (Dep.target) dep.addSub(Dep.target); return val &#125;, set: function (newVal) &#123; if (newVal === val) return val = newVal; // 作为发布者发出通知 dep.notify(); &#125; &#125;);&#125; 使用Proxy数据劫持的方式来实现：12345678910111213141516observe(data) &#123; const that = this; let handler = &#123; get(target, property) &#123; return target[property]; &#125;, set(target, key, value) &#123; let res = Reflect.set(target, key, value); that.subscribe[key].map(item =&gt; &#123; item.update(); &#125;); return res; &#125; &#125; this.$data = new Proxy(data, handler);&#125; 这段代码里把代理器返回的对象代理到this.$data，即this.$data是代理后的对象，外部每次对this.$data进行操作时，实际上执行的是这段代码里handler对象上的方法。 参考： vue3中的双向绑定 proxy vue3.0中的双向数据绑定方法]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue双向绑定原理]]></title>
    <url>%2F2020%2F11%2F08%2Fvue%2Fvue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文的双向绑定是简版的vue实现方式，不包含虚拟dom的实现等原理图：实现：我们要实现的是将如下代码，最终渲染成dom节点1234&lt;div id="app"&gt; &lt;input type="text" v-model="text"&gt; &#123;&#123; text &#125;&#125;&lt;/div&gt; 123456var vm = new Vue(&#123; el: 'app', data: &#123; text: 'hello world' &#125;&#125;) 1.Vue构造函数的实现可以通过如下3大步来完成dom的渲染： 添加监听器 遍历dom，编译模板 编译完成后，将dom插入到根节点12345678910111213function Vue (options) &#123; this.data = options.data; var data = this.data; // 1.添加监听器 observe(data, this); var id = options.el; // 2.遍历dom，编译模板 var dom = nodeToFragment(document.getElementById(id), this); // 3.编译完成后，将 dom 插入到根节点 document.getElementById(id).appendChild(dom); &#125; 2.使用observe，监听dataobserve方法会枚举每一个data，利用Object.defineProperty将data中的数据全部转换成getter/setter，当有新值赋给data，就会触发setter函数，然后通知订阅器Dep有更新1234567891011121314151617181920212223function observe (obj, vm) &#123; Object.keys(obj).forEach(function (key) &#123; defineReactive(vm, key, obj[key]); &#125;)&#125;function defineReactive (obj, key, val) &#123; var dep = new Dep(); Object.defineProperty(obj, key, &#123; get: function () &#123; // 添加订阅者 watcher 到主题对象 Dep if (Dep.target) dep.addSub(Dep.target); return val &#125;, set: function (newVal) &#123; if (newVal === val) return val = newVal; // 作为发布者发出通知 dep.notify(); &#125; &#125;);&#125; 3.订阅器Dep每个data都拥有一个订阅器Dep，Dep里面装着很多订阅者Watcher，当订阅器Dep收到data值改变的消息，就会通知所有watcher做更新1234567891011121314151617function Dep () &#123; this.subs = []&#125;Dep.prototype = &#123; // 添加订阅者 addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; // 通知每一个订阅者更新 this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125; 4.订阅者Watcherwatcher和使用该data的dom相关联，通过this可以访问该dom节点，所以可以通过watcher修改dom的文本属性，如，input组件:this.value = newData, 文本组件this.nodeValue = newData;当订阅器Dep收到data变化，就会通知里面的每一个watch改变dom值 123456789101112131415161718192021222324252627function Watcher (vm, node, name, nodeType) &#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.nodeType = nodeType; this.update(); Dep.target = null;&#125;Watcher.prototype = &#123; update: function () &#123; this.get(); // 更新&#123;&#123;&#125;&#125; if (this.nodeType == 'text') &#123; this.node.nodeValue = this.value; &#125; // 更新v-model if (this.nodeType == 'input') &#123; this.node.value = this.value; &#125; &#125;, // 获取 data 中的属性值 get: function () &#123; this.value = this.vm[this.name]; // 触发相应属性的 get &#125;&#125; 4.模板解析器Compile遍历所有dom，分别处理有v-model属性的元素节点和双花括号的文本节点： 将data值赋值给元素节点，如input赋值 替换文本节点的双花括号 为元素节点如input添加change事件，当value值改变时，更新被关联的data(此时双向绑定之一的view--&gt;model已完成)12345678910111213141516171819202122232425262728293031323334353637383940414243444546function nodeToFragment (node, vm) &#123; var flag = document.createDocumentFragment(); var child; // 许多同学反应看不懂这一段，这里有必要解释一下 // 首先，所有表达式必然会返回一个值，赋值表达式亦不例外 // 理解了上面这一点，就能理解 while (child = node.firstChild) 这种用法 // 其次，appendChild 方法有个隐蔽的地方，就是调用以后 child 会从原来 DOM 中移除 // 所以，第二次循环时，node.firstChild 已经不再是之前的第一个子元素了 while (child = node.firstChild) &#123; compile(child, vm); flag.appendChild(child); // 将子节点劫持到文档片段中 &#125; return flag&#125;function compile (node, vm) &#123; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; // 节点类型为元素 if (node.nodeType === 1) &#123; var attr = node.attributes; // 解析属性 for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName == 'v-model') &#123; var name = attr[i].nodeValue; // 获取 v-model 绑定的属性名 node.addEventListener('input', function (e) &#123; // 给相应的 data 属性赋值，进而触发该属性的 set 方法 vm[name] = e.target.value; &#125;); node.value = vm[name]; // 将 data 的值赋给该 node node.removeAttribute('v-model'); &#125; &#125;; new Watcher(vm, node, name, 'input'); &#125; // 节点类型为 text if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; var name = RegExp.$1; // 获取匹配到的字符串 name = name.trim(); new Watcher(vm, node, name, 'text'); &#125; &#125;&#125; 附上一副官网流程图： 参考： vue双向绑定原理 Vue数据双向绑定 解析vue双向绑定原理 完整代码]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustache模板引擎（二）]]></title>
    <url>%2F2020%2F10%2F26%2Fvue%2Fmustache%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E2%2F</url>
    <content type="text"><![CDATA[扫描器扫描器，主要作用是扫描到之后的数据，以及它们之间的数据，保存到token里，便于以后拼装12345678910111213141516171819202122232425262728293031323334// 扫描器class Scanner &#123; constructor(templateStr)&#123; this.pos = 0; this.tail = templateStr; this.templateStr = templateStr; &#125; // 扫描到'&#123;&#123;'后，重新赋值pos和tail // pos和tail都从'&#123;&#123;'后重新开始 scan(stopTag) &#123; if (this.tail.indexOf(stopTag) === 0) &#123; this.pos += stopTag.length; this.tail = this.templateStr.substring(this.pos); &#125; &#125; // 返回'&#123;&#123;'之前的值 scanUtil(stopTag) &#123; const pos_backup = this.pos; // 当尾巴的开头不是stopTag 的时候，就说明还没有扫描到stopTag while(this.tail.indexOf(stopTag) !==0 &amp;&amp; !this.eos())&#123; this.pos++; // 改变尾巴从当前指针的这个字符开始到最后 this.tail = this.templateStr.substr(this.pos); &#125; return this.templateStr.substring(pos_backup, this.pos); &#125; // 判断指针是否走到了头 eos()&#123; return this.pos &gt;= this.templateStr.length; &#125;&#125; 将模板转换成token什么是tokens，也就是将模板转换成如下数组结构：1234567891011121314` &lt;ol&gt; &#123;&#123;#students&#125;&#125; &lt;li&gt; 学生&#123;&#123;name&#125;&#125; 好朋友是&#123;&#123;friend.name&#125;&#125; 自己的爱好是 &lt;ol&gt; &#123;&#123;#hobbies&#125;&#125; &lt;li&gt;&#123;&#123;.&#125;&#125;&lt;/li&gt; &#123;&#123;/hobbies&#125;&#125; &lt;/ol&gt; &lt;/li&gt; &#123;&#123;/students&#125;&#125; &lt;/ol&gt;` 12345678910111213141516171819202122232425// 将模板转换成tokensfunction parseTemplateToTokens(templateStr) &#123; let tokens = []; let scanner = new Scanner(templateStr) let words; while(!scanner.eos())&#123; words = scanner.scanUtil('&#123;&#123;') if (words !== '' )&#123; tokens.push(['text',words.replace(/\s+/g,' ')]) // 将多个空格合并成一个 &#125; scanner.scan('&#123;&#123;') words = scanner.scanUtil('&#125;&#125;') if (words!=='')&#123; if (words[0]==='#')&#123; tokens.push(['#', words.substring(1)]); &#125; else if (words[0] === '/') &#123; tokens.push(['/', words.substring(1)]); &#125; else &#123; tokens.push(['name', words]) &#125; &#125; scanner.scan('&#125;&#125;') &#125; return nestTokens(tokens)&#125; 将tokens折叠#和/之间的token，是一个循环，应该属于上一个token的子项，折叠后的token结构如下：1234567891011121314151617181920212223// 将#开头的token，折叠进多维数组function nestTokens(tokens) &#123; let nestedTokens = []; // 结果数组 let sections = []; // 一个栈结构 let collector = nestedTokens; // 收集器 for (let i=0,len = tokens.length ;i&lt;len ;++i) &#123; let token = tokens[i]; switch (token[0]) &#123; case '#': collector.push(token); sections.push(token); collector = token[2] = []; // 给token 添加下标为2的项 并且让收集器指向它 break case '/': sections.pop(); collector = sections.length &gt;0 ? sections[sections.length - 1][2]:nestedTokens; break default: collector.push(token); &#125; &#125; return nestedTokens&#125; 将tokens渲染成dom思路是将token里面的字符串连接起来，双{}之间的东西，要用data替换1234567891011121314function renderTemplate (tokens, data) &#123; let resultStr = '' for (let i=0,len = tokens.length ; i&lt;len ; ++i )&#123; let token = tokens[i] if (token[0] === 'text') &#123; resultStr += token[1] &#125; else if (token[0] === 'name') &#123; resultStr += lookup (data, token[1]) &#125; else if (token[0] === '#') &#123; resultStr += parseArray(token, data) &#125; &#125; return resultStr&#125; 处理a.b.c因为a[b.c]是不能取到a.b.c的，数据的，所以要对级联.取值，做处理：123456789101112function lookup (dataObj, keyName) &#123; // 判断的时候不能是. 本身 if (keyName.indexOf('.') !== -1 &amp;&amp; keyName !== '.') &#123; let keys = keyName.split('.') let temp = dataObj for (let i=0, len = keys.length; i&lt;len ; ++i) &#123; temp = temp[keys[i]] &#125; return temp &#125; return dataObj[keyName] // 没有'.'&#125; 处理建议循环符.对于.代表，循环数组中的每一项，当访问父元素的点属性时，可以将数据本身复制给点1234567891011function parseArray(token, data) &#123; let v = lookup(data, token[1]); let resultStr = '' for (let i=0, len = v.length ;i&lt;len ;++i) &#123; resultStr += renderTemplate(token[2], &#123; ...v[i], '.': v[i] &#125;) &#125; return resultStr&#125; render函数调用主流程1234567function render (templateStr, data) &#123; let tokens = parseTemplateToTokens(templateStr) console.log(tokens) let result = renderTemplate(tokens,data) console.log (result) return result&#125; 调用1234567891011121314151617181920212223242526272829303132333435&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;mustache&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id ="container"&gt; &lt;/div&gt; &lt;script src="b.js"&gt;&lt;/script&gt; &lt;script&gt; var templateStr = ` &lt;ol&gt; &#123;&#123;#students&#125;&#125; &lt;li&gt; 学生&#123;&#123;name&#125;&#125; 好朋友是&#123;&#123;friend.name&#125;&#125; 自己的爱好是 &lt;ol&gt; &#123;&#123;#hobbies&#125;&#125; &lt;li&gt;&#123;&#123;.&#125;&#125;&lt;/li&gt; &#123;&#123;/hobbies&#125;&#125; &lt;/ol&gt; &lt;/li&gt; &#123;&#123;/students&#125;&#125; &lt;/ol&gt; ` var data = &#123; students: [ &#123;name: "小明", hobbies: ['编程', '打游戏'], friend: &#123;name: '小七'&#125;&#125;, &#123;name: "小红", hobbies: ['追剧'], friend: &#123;name: '小紫'&#125;&#125; ] &#125; document.getElementById("container").innerHTML = render(templateStr,data) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustache模板引擎（一）]]></title>
    <url>%2F2020%2F10%2F24%2Fvue%2Fmustache%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E1%2F</url>
    <content type="text"><![CDATA[什么是模板引擎数据变成视图的最优雅的解决方案,vue的模板引擎也借鉴于此 历史上曾经出现的数据变为视图的方法 纯DOM法：非常笨拙，没有实战价值 数组join法: 曾几何时非常流行，是曾经的前端必会知识 123456789101112for (var i=0,len = arr.length;i&lt;len;++i)&#123; list.innerHTML += [ '&lt;li&gt;', ' &lt;div class="hd"&gt;' +arr[i].name + '的基本信息&lt;/div&gt;', ' &lt;div class="bd"&gt;', ' &lt;p&gt;姓名：'+arr[i].name+'&lt;/p&gt;', ' &lt;p&gt;年龄：'+arr[i].age+'&lt;/p&gt;', ' &lt;p&gt;性别：'+arr[i].sex+'&lt;/p&gt;', ' &lt;/div&gt;', '&lt;/li&gt;' ].join('')&#125; ES6的反引号法：ES6中新增的${a}语法糖，很好用 123456789101112for (var i=0,len = arr.length;i&lt;len;++i)&#123; list.innerHTML += ` &lt;li&gt; &lt;div class="hd"&gt;$&#123;arr[i].name&#125;的基本信息&lt;/div&gt; &lt;div class="bd"&gt; &lt;p&gt;姓名：$&#123;arr[i].name&#125;&lt;/p&gt; &lt;p&gt;年龄：$&#123;arr[i].age&#125;&lt;/p&gt; &lt;p&gt;性别：$&#123;arr[i].sex&#125;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; `&#125; 模板引擎：解决数据变为视图的最优雅的方法 使用主要方法1.循环View:1234567&#123; "stooges": [ &#123; "name": "Moe" &#125;, &#123; "name": "Larry" &#125;, &#123; "name": "Curly" &#125; ]&#125; Template:123&#123;&#123;#stooges&#125;&#125;&lt;b&gt;&#123;&#123;name&#125;&#125;&lt;/b&gt;&#123;&#123;/stooges&#125;&#125; Output:123&lt;b&gt;Moe&lt;/b&gt;&lt;b&gt;Larry&lt;/b&gt;&lt;b&gt;Curly&lt;/b&gt; .简化数组循环View:123&#123; "musketeers": ["Athos", "Aramis", "Porthos", "D'Artagnan"]&#125; Template:123&#123;&#123;#musketeers&#125;&#125;* &#123;&#123;.&#125;&#125;&#123;&#123;/musketeers&#125;&#125; Output:1234* Athos* Aramis* Porthos* D&apos;Artagnan 实现需求实现一个建议的for循环模板，并支持.循环符 实现需求，将下列模板，关联data后，渲染成dom模板:12345678910111213141516171819202122var templateStr = ` &lt;ol&gt; &#123;&#123;#students&#125;&#125; &lt;li&gt; 学生&#123;&#123;name&#125;&#125; 好朋友是&#123;&#123;friend.name&#125;&#125; 自己的爱好是 &lt;ol&gt; &#123;&#123;#hobbies&#125;&#125; &lt;li&gt;&#123;&#123;.&#125;&#125;&lt;/li&gt; &#123;&#123;/hobbies&#125;&#125; &lt;/ol&gt; &lt;/li&gt; &#123;&#123;/students&#125;&#125; &lt;/ol&gt;`数据：```jsvar data = &#123; students: [ &#123;name: "小明", hobbies: ['编程', '打游戏'], friend: &#123;name: '小七'&#125;&#125;, &#123;name: "小红", hobbies: ['追剧'], friend: &#123;name: '小紫'&#125;&#125; ]&#125; 源码实现看下一篇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的diff算法（待整理）]]></title>
    <url>%2F2020%2F10%2F09%2Fvue%2Fvue%E7%9A%84diff%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是diff算法要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。 我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。 diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。 virtual DOM虚拟dom的节点属性如下：1234567&#123; sel: 'div', // 选择器，是什么标签 key: 'A', // key children: [], // 子元素 text: '文本', // 文本节点 elem: el // 关联真实dom&#125; diff的主要流程 patch来看看patch是怎么打补丁的（代码只保留核心部分）12345678910111213141516171819function patch (oldVnode, vnode) &#123; if (sameVnode(oldVnode, vnode)) &#123; // 相同节点（值得比较） patchVnode(oldVnode, vnode) &#125; else &#123; // 不同节点（暴力删除，替换新的，不复用） const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl) // 父元素 createEle(vnode) // 根据Vnode生成新元素 if (parentEle !== null) &#123; api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点 oldVnode = null &#125; &#125; // some code return vnode&#125; patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点 判断两节点是否值得比较，值得比较则执行patchVnode 12345678910function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; // key值 a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 )&#125; 不值得比较则用Vnode替换oldVnode如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。 虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…） patchVnode当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？1234567891011121314151617patchVnode (oldVnode, vnode) &#123; const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123; api.setTextContent(el, vnode.text) &#125;else &#123; updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123; updateChildren(el, oldCh, ch) &#125;else if (ch)&#123; createEle(vnode) //create el's children dom &#125;else if (oldCh)&#123; api.removeChildren(el) &#125; &#125;&#125; 这个函数做了以下事情： 找到对应的真实dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 其他几个点都很好理解，我们详细来讲一下updateChildren updateChildrenupdateChildren是diff算法的精髓123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869updateChildren (parentElm, oldCh, newCh) &#123; let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] &#125;else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125;else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx] &#125;else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125;else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125;else &#123; // 使用key时的比较 if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 &#125; idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125;else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125;else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 主要做了这5个事：1、旧头 == 新头 2、旧尾 == 新尾 3、旧头 == 新尾 4、旧尾 == 新头 5、单个查找 举个例子来说明一下：真实: [A, B, C, D, E]旧： [A, B, C, D, E]新: [A, F, C, G, E] 下面用下表1，代表指针在的位置 真实: [A, B, C, D, E]旧： [A1, B, C, D, E1]新: [A1, F, C, G, E1] 比较前4步，若头部指针匹配，则头部的指针往后移动；若尾部的指针匹配，则往前移动A1 == A1，头指针往后移动，再开始新一轮的5步比较；E1==E1，尾指针往后迁，如下2： 2.真实: [A, B, C, D, E]旧： [A, B1, C, D1, E]新: [A, F1, C, G1, E] F1前4步都不匹配，就循环，发现没有，则新建F，插入已处理的节点后，也就是A后，并标记F`,这一步直接在dom上操作，如下3： 3.真实: [A, F（新）, B, C, D, E]旧： [A, B1, C, D1, E]新: [A, F`, C1, G1, E] 新节点C的前4步都不匹配，则循环，在旧节点找到了C，则将C移动到已处理的节点后，即F(新)后 真实: [A, F（新）, C（移动）, B, C, D, E]旧： [A, B1, C, D1, E]新: [A, F, C, G11, E] G匹配5步都没有，则新建 真实: [A, F（新）, C（移动）, G（新建）, B, C, D, E]旧： [A, B1, C, D1, E]新: [A, F, C, G1, E1] G操作后，再往后移，此时，前指针移动到了后指针之后了，匹配结束，将旧节点两个之间的节点删除 6.真实: [A, F（新）, C（移动）, G（新建）, B删, C删, D删, E] 旧： [A, B1, C, D1, E] 新: [A, F, C`, G1, E1] =》 真实：[A, F, C, G, E] 重点：diff的比较方式进行同层比较，不会进行跨层比较，如：给一个子节点加上一个父节点，会认为父节点和以前的子节点是同层但不同，不会利用之前的子节点，而是将其删除后再创建vue的diff并不是“无微不至”，但上面的做法并不影响效率，因为实际代码很少有上面这种操作 在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较，这样将时间复杂度为 O(n3),Vue进行了优化·O(n3) 复杂度的问题转换成 O(n) 复杂度的问题(只比较同级不考虑跨级问题)，因为你很少会跨越层级地移动Dom元素。 所以 Virtual Dom只会对同一个层级的元素进行对比]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pace.js原理解析（三）]]></title>
    <url>%2F2020%2F09%2F27%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2Fpace-js%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%903%2F</url>
    <content type="text"><![CDATA[代码注释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052(function() &#123; var AjaxMonitor, Bar, DocumentMonitor, ElementMonitor, ElementTracker, EventLagMonitor, Evented, Events, NoTargetError, Pace, RequestIntercept, SOURCE_KEYS, Scaler, SocketRequestTracker, XHRRequestTracker, animation, avgAmplitude, bar, cancelAnimation, cancelAnimationFrame, defaultOptions, extend, extendNative, getFromDOM, getIntercept, handlePushState, ignoreStack, init, now, options, requestAnimationFrame, result, runAnimation, scalers, shouldIgnoreURL, shouldTrack, source, sources, uniScaler, _WebSocket, _XDomainRequest, _XMLHttpRequest, _i, _intercept, _len, _pushState, _ref, _ref1, _replaceState, // 1.[].slice === Array.prototype.slice // 2.自身的属性不同(因为原型与[]的区别) // 3.所以在本质上[]和Array.prototype没有本质区别,但是调用上是有区别的,但是根据专业检测,[]要更快一点 __slice = [].slice, __hasProp = &#123;&#125;.hasOwnProperty, // 没细看，感觉实现了一个继承 __extends = function(child, parent) &#123; for (var key in parent) &#123; if (__hasProp.call(parent, key)) child[key] = parent[key]; &#125; function ctor() &#123; this.constructor = child; &#125; ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; &#125;, __indexOf = [].indexOf || function(item) &#123; for (var i = 0, l = this.length; i &lt; l; i++) &#123; if (i in this &amp;&amp; this[i] === item) return i; &#125; return -1; &#125;; defaultOptions = &#123; catchupTime: 100, initialRate: .03, minTime: 250, ghostTime: 100, maxProgressPerFrame: 20, easeFactor: 1.25, startOnPageLoad: true, // 源码没有用到这个属性做很有意义的事 restartOnPushState: true, restartOnRequestAfter: 500, target: 'body', elements: &#123; checkInterval: 100, selectors: ['body'] &#125;, eventLag: &#123; minSamples: 10, sampleCount: 3, lagThreshold: 3 &#125;, ajax: &#123; trackMethods: ['GET'], trackWebSockets: true, ignoreURLs: [] &#125; &#125;; /* *https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now *和JavaScript中其他可用的时间类函数（比如Date.now）不同的是， *window.performance.now()返回的时间戳没有被限制在一毫秒的精确度内，而它使用了一个浮点数来达到微秒级别的精确度。 */ now = function() &#123; var _ref; return (_ref = typeof performance !== "undefined" &amp;&amp; performance !== null ? typeof performance.now === "function" ? performance.now() : void 0 : void 0) != null ? _ref : +(new Date); &#125;; requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame; if (requestAnimationFrame == null) &#123; requestAnimationFrame = function(fn) &#123; return setTimeout(fn, 50); &#125;; cancelAnimationFrame = function(id) &#123; return clearTimeout(id); &#125;; &#125; // ​每间隔33ms执行一次fn（fn就是检测所有实例都为done），并在下一帧再次开始33ms递归，直到所有实例都为done​ runAnimation = function(fn) &#123; var last, tick; last = now(); tick = function() &#123; var diff; diff = now() - last; if (diff &gt;= 33) &#123; last = now(); return fn(diff, function() &#123; // 下一帧执行tick，递归 return requestAnimationFrame(tick); &#125;); &#125; else &#123; // 不慢33ms，递归 return setTimeout(tick, 33 - diff); &#125; &#125;; return tick(); &#125;; // obj = &#123;a: ()=&gt; &#123;&#125;, b: 'string'&#125;, result(obj, a/b, arguments)等价于 obj.a() 或obj.b result = function() &#123; var args, key, obj; obj = arguments[0], key = arguments[1], args = 3 &lt;= arguments.length ? __slice.call(arguments, 2) : []; if (typeof obj[key] === 'function') &#123; return obj[key].apply(obj, args); &#125; else &#123; return obj[key]; &#125; &#125;; // 实现一个extend extend = function() &#123; var key, out, source, sources, val, _i, _len; out = arguments[0], sources = 2 &lt;= arguments.length ? __slice.call(arguments, 1) : []; for (_i = 0, _len = sources.length; _i &lt; _len; _i++) &#123; source = sources[_i]; if (source) &#123; for (key in source) &#123; if (!__hasProp.call(source, key)) continue; val = source[key]; if ((out[key] != null) &amp;&amp; typeof out[key] === 'object' &amp;&amp; (val != null) &amp;&amp; typeof val === 'object') &#123; extend(out[key], val); &#125; else &#123; out[key] = val; &#125; &#125; &#125; &#125; return out; &#125;; // 求数组每一项绝对值的和的平均值 // avgAmplitude([1, -1, 2, -2]) = 1.5 avgAmplitude = function(arr) &#123; var count, sum, v, _i, _len; sum = count = 0; for (_i = 0, _len = arr.length; _i &lt; _len; _i++) &#123; v = arr[_i]; sum += Math.abs(v); count++; &#125; return sum / count; &#125;; // 从data-pace-options里读取配置信息 // &lt;script data-pace-options='&#123; "ajax": false &#125;' src='pace.js'&gt;&lt;/script&gt; getFromDOM = function(key, json) &#123; var data, e, el; if (key == null) &#123; key = 'options'; &#125; if (json == null) &#123; json = true; &#125; el = document.querySelector("[data-pace-" + key + "]"); if (!el) &#123; return; &#125; data = el.getAttribute("data-pace-" + key); if (!json) &#123; return data; &#125; try &#123; return JSON.parse(data); &#125; catch (_error) &#123; e = _error; return typeof console !== "undefined" &amp;&amp; console !== null ? console.error("Error parsing inline pace options", e) : void 0; &#125; &#125;; // on监听方法，trigger触发方法，Evented原型里的方法被添加到Pace里 Evented = (function() &#123; function Evented() &#123;&#125; // on方法保存同名事件在一个数组 // Evented.bindings = &#123; // events: [ // event1, events2... // ] // &#125; // trigger(event) =&gt; handler.apply(ctx, args); Evented.prototype.on = function(event, handler, ctx, once) &#123; var _base; if (once == null) &#123; // 掉once方法时为true once = false; &#125; if (this.bindings == null) &#123; this.bindings = &#123;&#125;; &#125; if ((_base = this.bindings)[event] == null) &#123; _base[event] = []; &#125; return this.bindings[event].push(&#123; handler: handler, ctx: ctx, once: once &#125;); &#125;; Evented.prototype.once = function(event, handler, ctx) &#123; return this.on(event, handler, ctx, true); &#125;; // 若handler为空，则移空整个event数组，否则将this.bindings里存储的对应event移除 Evented.prototype.off = function(event, handler) &#123; var i, _ref, _results; if (((_ref = this.bindings) != null ? _ref[event] : void 0) == null) &#123; return; &#125; if (handler == null) &#123; return delete this.bindings[event]; &#125; else &#123; i = 0; _results = []; while (i &lt; this.bindings[event].length) &#123; if (this.bindings[event][i].handler === handler) &#123; _results.push(this.bindings[event].splice(i, 1)); &#125; else &#123; _results.push(i++); &#125; &#125; return _results; &#125; &#125;; // 将this.bindings里存储的events拿出来，在传入的this环境一个一个执行 Evented.prototype.trigger = function() &#123; var args, ctx, event, handler, i, once, _ref, _ref1, _results; event = arguments[0], args = 2 &lt;= arguments.length ? __slice.call(arguments, 1) : []; if ((_ref = this.bindings) != null ? _ref[event] : void 0) &#123; i = 0; _results = []; while (i &lt; this.bindings[event].length) &#123; _ref1 = this.bindings[event][i], handler = _ref1.handler, ctx = _ref1.ctx, once = _ref1.once; handler.apply(ctx != null ? ctx : this, args); if (once) &#123; _results.push(this.bindings[event].splice(i, 1)); &#125; else &#123; _results.push(i++); &#125; &#125; return _results; &#125; &#125;; return Evented; &#125;)(); Pace = window.Pace || &#123;&#125;; window.Pace = Pace; extend(Pace, Evented.prototype); options = Pace.options = extend(&#123;&#125;, defaultOptions, window.paceOptions, getFromDOM()); // window.paceOptions为true的属性，都使用defaultOptions的设置 _ref = ['ajax', 'document', 'eventLag', 'elements']; for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) &#123; source = _ref[_i]; if (options[source] === true) &#123; options[source] = defaultOptions[source]; &#125; &#125; // 没细看，感觉是继承了Error对象，不知道为什么这样做 NoTargetError = (function(_super) &#123; __extends(NoTargetError, _super); function NoTargetError() &#123; _ref1 = NoTargetError.__super__.constructor.apply(this, arguments); return _ref1; &#125; return NoTargetError; &#125;)(Error); Bar = (function() &#123; function Bar() &#123; this.progress = 0; &#125; Bar.prototype.getElement = function() &#123; var targetElement; if (this.el == null) &#123; targetElement = document.querySelector(options.target); if (!targetElement) &#123; throw new NoTargetError; &#125; // 渲染成这样，插入body下第一个元素 // &lt;div class="pace pace-inactive"&gt; // &lt;div class="pace-progress" data-progress-text="10%"&gt; // ::before // &lt;div class="pace-progress-inner"&gt;&lt;/div&gt; // &lt;/div&gt; // &lt;div class="pace-activity"&gt;&lt;/div&gt; // &lt;/div&gt; this.el = document.createElement('div'); this.el.className = "pace pace-active"; document.body.className = document.body.className.replace(/pace-done/g, ''); document.body.className += ' pace-running'; this.el.innerHTML = '&lt;div class="pace-progress"&gt;\n &lt;div class="pace-progress-inner"&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div class="pace-activity"&gt;&lt;/div&gt;'; if (targetElement.firstChild != null) &#123; targetElement.insertBefore(this.el, targetElement.firstChild); &#125; else &#123; targetElement.appendChild(this.el); &#125; &#125; return this.el; &#125;; Bar.prototype.finish = function() &#123; var el; el = this.getElement(); el.className = el.className.replace('pace-active', ''); el.className += ' pace-inactive'; document.body.className = document.body.className.replace('pace-running', ''); return document.body.className += ' pace-done'; &#125;; Bar.prototype.update = function(prog) &#123; this.progress = prog; return this.render(); &#125;; Bar.prototype.destroy = function() &#123; try &#123; this.getElement().parentNode.removeChild(this.getElement()); &#125; catch (_error) &#123; NoTargetError = _error; &#125; return this.el = void 0; &#125;; // 通过更新data-progress-text、data-progress属性，来影响css Bar.prototype.render = function() &#123; var el, key, progressStr, transform, _j, _len1, _ref2; if (document.querySelector(options.target) == null) &#123; return false; &#125; el = this.getElement(); transform = "translate3d(" + this.progress + "%, 0, 0)"; _ref2 = ['webkitTransform', 'msTransform', 'transform']; for (_j = 0, _len1 = _ref2.length; _j &lt; _len1; _j++) &#123; key = _ref2[_j]; el.children[0].style[key] = transform; &#125; if (!this.lastRenderedProgress || this.lastRenderedProgress | 0 !== this.progress | 0) &#123; // 进度文案更新 el.children[0].setAttribute('data-progress-text', "" + (this.progress | 0) + "%"); if (this.progress &gt;= 100) &#123; progressStr = '99'; &#125; else &#123; progressStr = this.progress &lt; 10 ? "0" : ""; progressStr += this.progress | 0; &#125; // 关联css rotate角度的样式 el.children[0].setAttribute('data-progress', "" + progressStr); &#125; return this.lastRenderedProgress = this.progress; &#125;; Bar.prototype.done = function() &#123; return this.progress &gt;= 100; &#125;; return Bar; &#125;)(); // on方法和trigger方法 Events = (function() &#123; function Events() &#123; this.bindings = &#123;&#125;; &#125; Events.prototype.trigger = function(name, val) &#123; var binding, _j, _len1, _ref2, _results; if (this.bindings[name] != null) &#123; _ref2 = this.bindings[name]; _results = []; for (_j = 0, _len1 = _ref2.length; _j &lt; _len1; _j++) &#123; binding = _ref2[_j]; _results.push(binding.call(this, val)); &#125; return _results; &#125; &#125;; Events.prototype.on = function(name, fn) &#123; var _base; if ((_base = this.bindings)[name] == null) &#123; _base[name] = []; &#125; return this.bindings[name].push(fn); &#125;; return Events; &#125;)(); _XMLHttpRequest = window.XMLHttpRequest; // IE8和IE9:XDomainRequest, IE10以上:XMLHttpRequest _XDomainRequest = window.XDomainRequest; _WebSocket = window.WebSocket; // to是模拟对象，from是原生对象，对于from对象里每个不是function的属性，to如果没有，就从form取 extendNative = function(to, from) &#123; var e, key, _results; _results = []; for (key in from.prototype) &#123; try &#123; if ((to[key] == null) &amp;&amp; typeof from[key] !== 'function') &#123; if (typeof Object.defineProperty === 'function') &#123; _results.push(Object.defineProperty(to, key, &#123; get: function() &#123; return from.prototype[key]; &#125;, configurable: true, enumerable: true &#125;)); &#125; else &#123; _results.push(to[key] = from.prototype[key]); &#125; &#125; else &#123; _results.push(void 0); &#125; &#125; catch (_error) &#123; e = _error; &#125; &#125; return _results; &#125;; ignoreStack = []; Pace.ignore = function() &#123; var args, fn, ret; fn = arguments[0], args = 2 &lt;= arguments.length ? __slice.call(arguments, 1) : []; ignoreStack.unshift('ignore'); ret = fn.apply(null, args); ignoreStack.shift(); return ret; &#125;; Pace.track = function() &#123; var args, fn, ret; fn = arguments[0], args = 2 &lt;= arguments.length ? __slice.call(arguments, 1) : []; ignoreStack.unshift('track'); ret = fn.apply(null, args); ignoreStack.shift(); return ret; &#125;; shouldTrack = function(method) &#123; var _ref2; if (method == null) &#123; method = 'GET'; &#125; if (ignoreStack[0] === 'track') &#123; return 'force'; &#125; if (!ignoreStack.length &amp;&amp; options.ajax) &#123; if (method === 'socket' &amp;&amp; options.ajax.trackWebSockets) &#123; return true; &#125; else if (_ref2 = method.toUpperCase(), __indexOf.call(options.ajax.trackMethods, _ref2) &gt;= 0) &#123; return true; &#125; &#125; return false; &#125;; // 封装发送ajax请求的XMLHttpRequest，XDomainRequest 的代理 RequestIntercept = (function(_super) &#123; // RequestIntercept继承了Events里的on、trigger __extends(RequestIntercept, _super); function RequestIntercept() &#123; var monitorXHR, _this = this; RequestIntercept.__super__.constructor.apply(this, arguments); // 代理xhr的open方法 monitorXHR = function(req) &#123; var _open; _open = req.open; return req.open = function(type, url, async) &#123; if (shouldTrack(type)) &#123; _this.trigger('request', &#123; type: type, url: url, request: req &#125;); &#125; return _open.apply(req, arguments); &#125;; &#125;; // new了一个原生xhr，返回一个代理后的xhr window.XMLHttpRequest = function(flags) &#123; var req; req = new _XMLHttpRequest(flags); monitorXHR(req); return req; &#125;; // 进一步完善代理xhr，除open，其它方法从用原生中继承 try &#123; extendNative(window.XMLHttpRequest, _XMLHttpRequest); &#125; catch (_error) &#123;&#125; // 以下是 代理 IE8和IE9:XDomainRequest，可不看 if (_XDomainRequest != null) &#123; window.XDomainRequest = function() &#123; var req; req = new _XDomainRequest; monitorXHR(req); return req; &#125;; try &#123; extendNative(window.XDomainRequest, _XDomainRequest); &#125; catch (_error) &#123;&#125; &#125; if ((_WebSocket != null) &amp;&amp; options.ajax.trackWebSockets) &#123; window.WebSocket = function(url, protocols) &#123; var req; if (protocols != null) &#123; req = new _WebSocket(url, protocols); &#125; else &#123; req = new _WebSocket(url); &#125; if (shouldTrack('socket')) &#123; _this.trigger('request', &#123; type: 'socket', url: url, protocols: protocols, request: req &#125;); &#125; return req; &#125;; try &#123; extendNative(window.WebSocket, _WebSocket); &#125; catch (_error) &#123;&#125; &#125; &#125; return RequestIntercept; &#125;)(Events); _intercept = null; getIntercept = function() &#123; if (_intercept == null) &#123; _intercept = new RequestIntercept; &#125; return _intercept; &#125;; // 对传入的url进行检测，若在ignoreURLs中，返回true，否则false shouldIgnoreURL = function(url) &#123; var pattern, _j, _len1, _ref2; _ref2 = options.ajax.ignoreURLs; for (_j = 0, _len1 = _ref2.length; _j &lt; _len1; _j++) &#123; pattern = _ref2[_j]; if (typeof pattern === 'string') &#123; if (url.indexOf(pattern) !== -1) &#123; return true; &#125; &#125; else &#123; if (pattern.test(url)) &#123; return true; &#125; &#125; &#125; return false; &#125;; // init()时，Pace.sources装了4个实例，找出AjaxMonitor的实例，若0 &lt; readyState &lt; 4，执行AjaxMonitor.watch() getIntercept().on('request', function(_arg) &#123; var after, args, request, type, url; type = _arg.type, request = _arg.request, url = _arg.url; if (shouldIgnoreURL(url)) &#123; return; &#125; if (!Pace.running &amp;&amp; (options.restartOnRequestAfter !== false || shouldTrack(type) === 'force')) &#123; args = arguments; after = options.restartOnRequestAfter || 0; if (typeof after === 'boolean') &#123; after = 0; &#125; return setTimeout(function() &#123; var stillActive, _j, _len1, _ref2, _ref3, _results; if (type === 'socket') &#123; stillActive = request.readyState &lt; 2; &#125; else &#123; // 0: 请求未初始化 ---- 代理被创建，但尚未调用 open() 方法 // 1: 服务器连接已建立 ---- open() 方法已经被调用。 // 2: 请求已接收 ---- send() 方法已经被调用，并且头部和状态已经可获得。 // 3: 请求处理中 // 4: 请求已完成，且响应已就绪 // 0 &lt; readyState &lt; 4，请求未完成 stillActive = (0 &lt; (_ref2 = request.readyState) &amp;&amp; _ref2 &lt; 4); &#125; if (stillActive) &#123; Pace.restart(); // ajax: AjaxMonitor, // elements: ElementMonitor, // document: DocumentMonitor, // eventLag: EventLagMonitor // Pace.sources里是上面4个的实例 _ref3 = Pace.sources; _results = []; // 如果有AjaxMonitor的实例，执行watch方法 for (_j = 0, _len1 = _ref3.length; _j &lt; _len1; _j++) &#123; source = _ref3[_j]; if (source instanceof AjaxMonitor) &#123; source.watch.apply(source, args); break; &#125; else &#123; _results.push(void 0); &#125; &#125; return _results; &#125; &#125;, after); &#125; &#125;); // this.elements = []，里面保存有XHRRequestTracker实例，有progres属性 AjaxMonitor = (function() &#123; function AjaxMonitor() &#123; var _this = this; this.elements = []; getIntercept().on('request', function() &#123; return _this.watch.apply(_this, arguments); &#125;); &#125; // AjaxMonitor.elements.push(tracker); AjaxMonitor.prototype.watch = function(_arg) &#123; var request, tracker, type, url; type = _arg.type, request = _arg.request, url = _arg.url; if (shouldIgnoreURL(url)) &#123; return; &#125; if (type === 'socket') &#123; tracker = new SocketRequestTracker(request); &#125; else &#123; tracker = new XHRRequestTracker(request); &#125; return this.elements.push(tracker); &#125;; return AjaxMonitor; &#125;)(); // 监听xhr，根据浏览器是否支持ProgressEvent，算出progress XHRRequestTracker = (function() &#123; function XHRRequestTracker(request) &#123; var event, size, _j, _len1, _onreadystatechange, _ref2, _this = this; this.progress = 0; // ProgressEvent 接口是测量如 HTTP 请求（一个XMLHttpRequest，或者一个 &lt;img&gt;，&lt;audio&gt;，&lt;video&gt;，&lt;style&gt; 或 &lt;link&gt; 等底层资源的加载）等底层流程进度的事件。 if (window.ProgressEvent != null) &#123; size = null; // https://developer.mozilla.org/zh-CN/docs/Web/API/ProgressEvent // progress事件会在浏览器接收新数据期间周期性地触发。 // 而onprogress事件处理程序会接收到一个event对象，其target属性是XHR对象， // 但包含着三个额外的属性：lengthComputable、loaded和total。 // 其中，lengthComputable告诉我们进度是否可以被测量，loaded表示已经接收的字节数， // loaded表示根据Content-Length响应头部确定的预期字节数 request.addEventListener('progress', function(evt) &#123; if (evt.lengthComputable) &#123; return _this.progress = 100 * evt.loaded / evt.total; &#125; else &#123; return _this.progress = _this.progress + (100 - _this.progress) / 2; &#125; &#125;, false); // 若监听到以下请求错误事件，progress=100，如：'abort'、'timeout'、'error' // 若请求成功完成时触发load，progress=100 _ref2 = ['load', 'abort', 'timeout', 'error']; for (_j = 0, _len1 = _ref2.length; _j &lt; _len1; _j++) &#123; event = _ref2[_j]; request.addEventListener(event, function() &#123; return _this.progress = 100; &#125;, false); &#125; &#125; else &#123; // 不支持ProgressEvent的浏览器，监听readyState，50 ，100 _onreadystatechange = request.onreadystatechange; request.onreadystatechange = function() &#123; var _ref3; if ((_ref3 = request.readyState) === 0 || _ref3 === 4) &#123; _this.progress = 100; &#125; else if (request.readyState === 3) &#123; _this.progress = 50; &#125; return typeof _onreadystatechange === "function" ? _onreadystatechange.apply(null, arguments) : void 0; &#125;; &#125; &#125; return XHRRequestTracker; &#125;)(); SocketRequestTracker = (function() &#123; function SocketRequestTracker(request) &#123; var event, _j, _len1, _ref2, _this = this; this.progress = 0; _ref2 = ['error', 'open']; for (_j = 0, _len1 = _ref2.length; _j &lt; _len1; _j++) &#123; event = _ref2[_j]; request.addEventListener(event, function() &#123; return _this.progress = 100; &#125;, false); &#125; &#125; return SocketRequestTracker; &#125;)(); // options.selectors=[]里面存的是要跟踪的dom元素，dom加载成功，progress=100% // 该实例的this.elements里存着tracker（每个tracker映射着selectors里的dom），每个tracker都会每隔100ms，查询一次dom是否存在，若是则this.progress = 100 ElementMonitor = (function() &#123; function ElementMonitor(options) &#123; var selector, _j, _len1, _ref2; if (options == null) &#123; options = &#123;&#125;; &#125; this.elements = []; if (options.selectors == null) &#123; options.selectors = []; &#125; _ref2 = options.selectors; for (_j = 0, _len1 = _ref2.length; _j &lt; _len1; _j++) &#123; selector = _ref2[_j]; this.elements.push(new ElementTracker(selector)); &#125; &#125; return ElementMonitor; &#125;)(); // 每隔100ms，查询一次dom是否存在，若是则this.progress = 100 ElementTracker = (function() &#123; function ElementTracker(selector) &#123; this.selector = selector; this.progress = 0; this.check(); &#125; ElementTracker.prototype.check = function() &#123; var _this = this; if (document.querySelector(this.selector)) &#123; return this.done(); &#125; else &#123; return setTimeout((function() &#123; return _this.check(); &#125;), options.elements.checkInterval); &#125; &#125;; ElementTracker.prototype.done = function() &#123; return this.progress = 100; &#125;; return ElementTracker; &#125;)(); /* Document.readyState 属性描述了document 的加载状态。 * 1.loading:正在加载 * 2.interactive:可交互,文档已被解析，"正在加载"状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载。 * 3. complete（完成）,文档和所有子资源已完成加载。表示 load 状态的事件即将被触发。 * * 这个三个状态分别对应的进度this.progresss = 0% 、50% 、100% */ DocumentMonitor = (function() &#123; DocumentMonitor.prototype.states = &#123; loading: 0, interactive: 50, complete: 100 &#125;; function DocumentMonitor() &#123; var _onreadystatechange, _ref2, _this = this; this.progress = (_ref2 = this.states[document.readyState]) != null ? _ref2 : 100; _onreadystatechange = document.onreadystatechange; document.onreadystatechange = function() &#123; if (_this.states[document.readyState] != null) &#123; _this.progress = _this.states[document.readyState]; &#125; return typeof _onreadystatechange === "function" ? _onreadystatechange.apply(null, arguments) : void 0; &#125;; &#125; return DocumentMonitor; &#125;)(); //EventLagMonitor其实只是一个“假的”监视器。它就在那里安静匀速的更新进度，这一小小的措施却带来了不错的用户体验，让用户不会因为加载“卡住了”而慌张 // 感觉怎么计算进度是一个数学问题，求一个数组绝对值的和的平均值，大于几小于几时，_this.progress = 100; EventLagMonitor = (function() &#123; function EventLagMonitor() &#123; var avg, interval, last, points, samples, _this = this; this.progress = 0; avg = 0; samples = []; points = 0; last = now(); interval = setInterval(function() &#123; var diff; diff = now() - last - 50; last = now(); samples.push(diff); if (samples.length &gt; options.eventLag.sampleCount) &#123; samples.shift(); &#125; // 求数组每一项绝对值的和的平均值，avgAmplitude([1, -1, 2, -2]) = 1.5 avg = avgAmplitude(samples); // ++points &gt;= 10 &amp;&amp; avg &lt; 3 if (++points &gt;= options.eventLag.minSamples &amp;&amp; avg &lt; options.eventLag.lagThreshold) &#123; _this.progress = 100; return clearInterval(interval); &#125; else &#123; return _this.progress = 100 * (3 / (avg + 3)); &#125; &#125;, 50); &#125; return EventLagMonitor; &#125;)(); // Scaler会取出实例的progress值，Scaler.tick()会将增加后的progress返回; Scaler = (function() &#123; function Scaler(source) &#123; this.source = source; this.last = this.sinceLastUpdate = 0; this.rate = options.initialRate; this.catchup = 0; this.progress = this.lastProgress = 0; if (this.source != null) &#123; this.progress = result(this.source, 'progress'); &#125; &#125; // 取到实例初始进度progress，以某种计算方式，使progress的值增大一点，再返回处理后的progress Scaler.prototype.tick = function(frameTime, val) &#123; var scaling; // 取到实例初始进度 if (val == null) &#123; val = result(this.source, 'progress'); &#125; if (val &gt;= 100) &#123; // 这个属性很重要，for每个实例时，都会取对应的scaler.done，全部为true才bar.finish(),否则继续递归检测 this.done = true; &#125; if (val === this.last) &#123; this.sinceLastUpdate += frameTime; &#125; else &#123; if (this.sinceLastUpdate) &#123; this.rate = (val - this.last) / this.sinceLastUpdate; &#125; this.catchup = (val - this.progress) / options.catchupTime; this.sinceLastUpdate = 0; this.last = val; &#125; if (val &gt; this.progress) &#123; this.progress += this.catchup * frameTime; &#125; scaling = 1 - Math.pow(this.progress / 100, options.easeFactor); // progress进度需要不停的增加，每次增加多少，通过上面的计算 this.progress += scaling * this.rate * frameTime; // 如果增量算的太多，不太合适，所以（初始progress + 20）和上面计算的progress取个最小值，也就是每次算的增量最大幅度是20（maxProgressPerFrame） this.progress = Math.min(this.lastProgress + options.maxProgressPerFrame, this.progress); this.progress = Math.max(0, this.progress); this.progress = Math.min(100, this.progress); this.lastProgress = this.progress; // 返回增加一定进度的progress return this.progress; &#125;; return Scaler; &#125;)(); sources = null; scalers = null; bar = null; uniScaler = null; animation = null; cancelAnimation = null; Pace.running = false; handlePushState = function() &#123; if (options.restartOnPushState) &#123; return Pace.restart(); &#125; &#125;; if (window.history.pushState != null) &#123; _pushState = window.history.pushState; window.history.pushState = function() &#123; handlePushState(); return _pushState.apply(window.history, arguments); &#125;; &#125; if (window.history.replaceState != null) &#123; _replaceState = window.history.replaceState; window.history.replaceState = function() &#123; handlePushState(); return _replaceState.apply(window.history, arguments); &#125;; &#125; SOURCE_KEYS = &#123; ajax: AjaxMonitor, elements: ElementMonitor, document: DocumentMonitor, eventLag: EventLagMonitor &#125;; // 声明后，直接调用init(),后面还可以再调用init (init = function() &#123; var type, _j, _k, _len1, _len2, _ref2, _ref3, _ref4; Pace.sources = sources = []; _ref2 = ['ajax', 'elements', 'document', 'eventLag']; for (_j = 0, _len1 = _ref2.length; _j &lt; _len1; _j++) &#123; type = _ref2[_j]; if (options[type] !== false) &#123; sources.push(new SOURCE_KEYS[type](options[type])); &#125; &#125; // 没看见options.extraSources赋过值 _ref4 = (_ref3 = options.extraSources) != null ? _ref3 : []; for (_k = 0, _len2 = _ref4.length; _k &lt; _len2; _k++) &#123; source = _ref4[_k]; sources.push(new source(options)); &#125; // Bar就是进度条dom实例，进度百分比关联着progress的值 Pace.bar = bar = new Bar; scalers = []; // Scaler会取出实例的progress值，Scaler.tick()会将progress值增加一点后返回; return uniScaler = new Scaler; &#125;)(); Pace.stop = function() &#123; Pace.trigger('stop'); Pace.running = false; bar.destroy(); cancelAnimation = true; if (animation != null) &#123; if (typeof cancelAnimationFrame === "function") &#123; cancelAnimationFrame(animation); &#125; animation = null; &#125; return init(); &#125;; Pace.restart = function() &#123; Pace.trigger('restart');// 未见监听 Pace.stop(); return Pace.start(); &#125;; Pace.go = function() &#123; var start; Pace.running = true; bar.render(); start = now(); cancelAnimation = false; // 每间隔33ms检查所有实例是否都为done，否则下一帧继续间隔33ms的递归检测 return animation = runAnimation(function(frameTime, enqueueNextFrame) &#123; var avg, count, done, element, elements, i, j, remaining, scaler, scalerList, sum, _j, _k, _len1, _len2, _ref2; remaining = 100 - bar.progress; count = sum = 0; done = true; for (i = _j = 0, _len1 = sources.length; _j &lt; _len1; i = ++_j) &#123; source = sources[i]; scalerList = scalers[i] != null ? scalers[i] : scalers[i] = []; elements = (_ref2 = source.elements) != null ? _ref2 : [source]; for (j = _k = 0, _len2 = elements.length; _k &lt; _len2; j = ++_k) &#123; element = elements[j]; scaler = scalerList[j] != null ? scalerList[j] : scalerList[j] = new Scaler(element); // a&amp;=b就是a=a&amp;b，有一个scaler.done不为true，done就不为true 逻辑语言运算符 done &amp;= scaler.done; if (scaler.done) &#123; continue; &#125; // done不为true的element，求个数总和，scaler.tick会取出progress，再得到进度总和 count++; sum += scaler.tick(frameTime); &#125; &#125; // 得到平均进度progress avg = sum / count; bar.update(uniScaler.tick(frameTime, avg)); // elements里实例的状态都是done了，进度100%，hide掉bar if (bar.done() || done || cancelAnimation) &#123; bar.update(100); Pace.trigger('done'); return setTimeout(function() &#123; bar.finish(); Pace.running = false; return Pace.trigger('hide'); &#125;, Math.max(options.ghostTime, Math.max(options.minTime - (now() - start), 0))); &#125; else &#123; return enqueueNextFrame(); &#125; &#125;); &#125;; Pace.start = function(_options) &#123; extend(options, _options); Pace.running = true; try &#123; bar.render(); &#125; catch (_error) &#123; NoTargetError = _error; &#125; // 如果找不到bar的话，说明bar.render失败，每隔50s 再render()一次 if (!document.querySelector('.pace')) &#123; return setTimeout(Pace.start, 50); &#125; else &#123; Pace.trigger('start');// 未找到Pace.on('start')方法监听trigger return Pace.go(); &#125; &#125;; // if (typeof define === 'function' &amp;&amp; define.amd) &#123; // console.log(32323) // define(['pace'], function() &#123; // return Pace; // &#125;); // &#125; else if (typeof exports === 'object') &#123; // module.exports = Pace; // &#125; else &#123; // if (options.startOnPageLoad) &#123; // Pace.start(); // &#125; // &#125; if (options.startOnPageLoad) &#123; Pace.start(); &#125;&#125;).call(this);]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pace.js原理解析（二）]]></title>
    <url>%2F2020%2F09%2F25%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2Fpace-js%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902%2F</url>
    <content type="text"><![CDATA[initPace.sourcesPace.sources = [ ]push进去4个实例：’ajax’, ‘elements’, ‘document’, ‘eventLag’ AjaxMonitorRequestIntercept封装发送ajax请求的XMLHttpRequest，XDomainRequest 的代理 req.open方法调用时，触发了trigger(‘request’)事件它有两个方法：一、trigger(‘request’)req.open方法时触发 二、on(‘request’）1.监听req.open方法2.遍历Pace.sources里的实例，若是AjaxMonitor的实例，调用其watch ()方法3.watch方法会AjaxMonitor.elements.push(XHRRequestTracker) 总结：每发一个ajax请求，AjaxMonitor的elements属性就push进去一个tracker， AjaxMonitorthis.elements = []，里面保存有tracker实例，而tracker有progres属性 XHRRequestTracker监听xhr，request.addEventListener(‘progress’），根据浏览器是否支持ProgressEvent，算出进度，存储在this.progress 1.progress事件会在浏览器接收新数据期间周期性地触发。2.而onprogress事件处理程序会接收到一个event对象，其target属性是XHR对象3.但包含着三个额外的属性：lengthComputable、loaded和total。4.lengthComputable：是一个表示进度信息是否可用的布尔值；loaded：表示已经接收的字节数，loaded：表示根据Content-Length响应头部确定的预期字节数5.不支持ProgressEvent的浏览器，监听readyState为3、4分别对应50% 、100% ElementMonitorPace.options.selectors=[]里面存的是要跟踪的doms元素，doms加载都成功，progress=100% ElementMonitor实例的this.elements里存着selectors里的dom对应的tracker（每个tracker映射着selectors里的dom），每个tracker都会每隔100ms，查询一次dom是否存在，若是则this.progress = 100 DocumentMonitorDocument.readyState 属性描述了document 的加载状态 1.loading:正在加载2.interactive:可交互,文档已被解析，”正在加载”状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载。 3. complete（完成）,文档和所有子资源已完成加载。表示 load 状态的事件即将被触发。 这个三个状态分别对应的进度this.progresss = 0% 、50% 、100% EventLagMonitor EventLagMonitor其实只是一个“假的”监视器。它就在那里安静匀速的更新进度，这一小小的措施却带来了不错的用户体验，让用户不会因为加载“卡住了”而慌张 感觉怎么计算进度是一个数学问题，求一个数组绝对值的和的平均值，大于几小于几时，_this.progress = 100;​（具体见代码） new Bar( )Bar就是进度条dom实例，进度百分比关联着progress的值 setAttribute(‘data-progress-text’, 10%) 12/* 如果你不想把content内容在CSS里写死，那你可以使用attr表达式来从页面元素中动态的获取内容 */.pace-progress:before &#123;content: attr(data-progress-text);​ new Scaler( )Scaler会取出实例的progress值，Scaler.tick()会将progress值增加一点后返回 Scaler.tick()：此方法主要用于返回this.progress，而progress需要不断增加，计算增加多少的方式很有意思，如果增量算的太多，不太合适，所以（初始progress + 20）和上面计算的progress取个最小值，也就是每次算的增量最大幅度是20（maxProgressPerFrame） pace.start( )主要做一件事，执行bar.render()，也就是插入bar的dom，​如果页面还未加载，则每隔50ms再Pace.start()一次 1.Pace.go()每隔33ms执行一次runAnimationwindow.performence. now() 比Date.now不同的是，window.performance.now()返回的时间戳没有被限制在一毫秒的精确度内，而它使用了一个浮点数来达到微秒级别的精确度 2.runAnimation( fn )很有意思的一个函数：33ms后才会执行fn，否则一直等到33ms后；fn函数被执行后，若返回false，会在下一帧继续执行runAnimation（也就是再等33ms执行一次fn），直到返回true总结：每间隔33ms执行一次fn（fn就是检测所有实例都为done），并在下一帧再次开始33ms递归，直到所有实例都为done​3.fn 取出所有实例的element，每个element都有一个Scaler实例(否则new一个存起来)，scaler.done表示实例的进度是否完成 for循环，done &amp;= scaler.done（ a&amp;=b就是a=a&amp;b，有一个scaler.done不为true，done就不为true）3.把不为done的实例， 对这些实例取出pregress，求平均进度，avg = sum / count; 再bar.update(avg)更新bar实例的进度 若所有done为true，bar.finish();]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pace.js原理解析（一）]]></title>
    <url>%2F2020%2F09%2F23%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2Fpace-js%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%901%2F</url>
    <content type="text"><![CDATA[Pace.js是什么？Pace能自动监控页面的加载进度，生成进度条。它能够自动监控ajax请求、事件循环延迟、document就绪状态和页面上的元素，并当再次发送ajax请求，也能够重启进度条。官网 特点1.配置简单1234&lt;head&gt; &lt;script src="/pace/pace.js"&gt;&lt;/script&gt; &lt;link href="/pace/themes/pace-theme-barber-shop.css" rel="stylesheet" /&gt;&lt;/head&gt; 2.体积小pace.js is 4kb minified and gzipped. The themes vary between 0.5 and 4kb.1000行左右 3.能够自动收集页面4个方面的进度信息，对应着Pace的4个主要Collectors： ajax监听所有页面的ajax请求进度 Elements监听dom元素的是否渲染到页面的进度 Document监听页面document的加载进度 Event Lag只是一个“假的”监视器。它就在那里安静匀速的更新进度，这一小小的措施却带来了不错的用户体验，让用户不会因为加载“卡住了”而慌张12345678paceOptions = &#123; ajax: false, // disabled document: false, // disabled eventLag: false, // disabled elements: &#123; selectors: ['.my-page'] &#125;&#125;; 问题 仅仅引入了一个js，业务代码里也没有调用特殊的ajax请求方法，pace是如何监听ajax请求的？ 如何监听document文档的载入进度？ 怎样为了用户体验实现一个假的进度？ 一个页面初始化时，并不止一个ajax请求，多个ajax的进度、document文档载入进度、dom渲染到页面的进度，这么多进度是如何整合成一个总进度的？ 例如一个请求，请求时间是不确定的，pace是如何预知请求时长，并生成进度的？ 解析请看下一篇]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise——结合源码看的十道题目]]></title>
    <url>%2F2020%2F08%2F29%2FPromise%2F%E7%9C%8B%E4%BA%86%E5%BF%85%E6%87%82%E7%9A%84Promise%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目1.123456789const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve() console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4) 搞清楚宏任务和微任务的执行顺序（先宏任务，再微任务，以此循环…）js 宏任务和微任务典型的微任务： Promise、process.nextTick典型的宏任务：setTimeout 题目2.12345678910111213141516const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success') &#125;, 1000)&#125;)const promise2 = promise1.then(() =&gt; &#123; throw new Error('error!!!')&#125;)console.log('promise1', promise1)console.log('promise2', promise2)setTimeout(() =&gt; &#123; console.log('promise1', promise1) console.log('promise2', promise2)&#125;, 2000) 题目3.12345678910111213const promise = new Promise((resolve, reject) =&gt; &#123; resolve('success1') reject('error') resolve('success2')&#125;)promise .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;) 为什么连续调用了resolve()、reject()、resolve()3次，只有第一个会执行？，从源码中可以看到，不管是resove还是reject，只有value===’pedding’,才会执行，而第一次的resolve()已经把状态置成了’fulfilled’，不再是’pedding’，代码如下：123456789const resolve = value =&gt; &#123; setTimeout(() =&gt; &#123; // 只有状态是PENDING，才会执行后续 if (this.state === PENDING) &#123; ... &#125; &#125;);&#125;; 题目4.1234567891011Promise.resolve(1) .then((res) =&gt; &#123; console.log(res) return 2 &#125;) .catch((err) =&gt; &#123; return 3 &#125;) .then((res) =&gt; &#123; console.log(res) &#125;) 题目5.1234567891011121314const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('once') resolve('success') &#125;, 1000)&#125;)const start = Date.now()promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;)promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;) 题目6.12345678910Promise.resolve() .then(() =&gt; &#123; return new Error('error!!!') &#125;) .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;) 题目7.12345const promise = Promise.resolve() .then(() =&gt; &#123; return promise &#125;)promise.catch(console.error) 题目8.1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) promise的透传，首先1传了第一个then，但then(fn)函数期待参数fn是个函数，但确传了个数值2，所以promise会如封装一个函数return (p) =&gt; p,这里p是1，所以就会一直之执行resove(1)透传下去 题目9.123456789Promise.resolve() .then(function success (res) &#123; throw new Error('error') &#125;, function fail1 (e) &#123; console.error('fail1: ', e) &#125;) .catch(function fail2 (e) &#123; console.error('fail2: ', e) &#125;)]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise源码实现——版本二]]></title>
    <url>%2F2020%2F08%2F27%2FPromise%2FPromise%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B02%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228const PENDING = 'pending';const FULFILLED = 'fulfilled';const REJECTED = 'rejected';class AjPromise &#123; constructor(fn) &#123; this.state = PENDING; this.value = null; this.reason = null; this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; const resolve = value =&gt; &#123; if (value instanceof Promise) &#123; return value.then(resolve, reject); &#125; setTimeout(() =&gt; &#123; if (this.state === PENDING) &#123; this.state = FULFILLED; this.value = value; this.onFulfilledCallbacks.map(cb =&gt; &#123; cb = cb(this.value); &#125;); &#125; &#125;); &#125;; const reject = reason =&gt; &#123; setTimeout(() =&gt; &#123; if (this.state === PENDING) &#123; this.state = REJECTED; this.reason = reason; this.onRejectedCallbacks.map(cb =&gt; &#123; cb = cb(this.reason); &#125;); &#125; &#125;); &#125;; try &#123; fn(resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125; then(onFulfilled, onRejected) &#123; let newPromise; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; &#123; throw reason; &#125;; if (this.state === FULFILLED) &#123; return (newPromise = new AjPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value); resolvePromise(newPromise, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;)); &#125; if (this.state === REJECTED) &#123; return (newPromise = new AjPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(newPromise, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;)); &#125; if (this.state === PENDING) &#123; return (newPromise = new AjPromise((resolve, reject) =&gt; &#123; this.onFulfilledCallbacks.push(value =&gt; &#123; try &#123; let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); this.onRejectedCallbacks.push(reason =&gt; &#123; try &#123; let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;)); &#125; &#125; catch(onRejected) &#123; return this.then(null, onRejected); &#125;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; if (x === promise2) &#123; reject(new TypeError('循环引用')); &#125; if (x instanceof AjPromise) &#123; if (x.state === PENDING) &#123; x.then( y =&gt; &#123; resolvePromise(promise2, y, resolve, reject); &#125;, reason =&gt; &#123; reject(reason); &#125; ); &#125; else &#123; x.then(resolve, reject); &#125; &#125; else if (x &amp;&amp; (typeof x === 'function' || typeof x === 'object')) &#123; let called = false; try &#123; let then = x.then; if (typeof then === 'function') &#123; then.call( x, y =&gt; &#123; if (called) return; called = true; resolvePromise(promise2, y, resolve, reject); &#125;, r =&gt; &#123; if (called) return; called = true; reject(r); &#125; ); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;AjPromise.all = function(promises) &#123; return new AjPromise((resolve, reject) =&gt; &#123; let done = gen(promises.length, resolve); promises.forEach((promise, index) =&gt; &#123; promise.then(value =&gt; &#123; done(index, value); &#125;, reject); &#125;); &#125;);&#125;;function gen(length, resolve) &#123; let count = 0; let values = []; return function(i, value) &#123; values[i] = value; if (++count === length) &#123; resolve(values); &#125; &#125;;&#125;AjPromise.race = function(promises) &#123; return new AjPromise((resolve, reject) =&gt; &#123; for (var i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve, reject); &#125; &#125;);&#125;;AjPromise.resolve = function(value) &#123; return new AjPromise((resolve, reject) =&gt; resolve(value));&#125;;AjPromise.reject = function(reason) &#123; return new AjPromise((resolve, reject) =&gt; reject(reason));&#125;;AjPromise.deferred = function() &#123; let defer = &#123;&#125;; defer.promise = new AjPromise((resolve, reject) =&gt; &#123; defer.resolve = resolve; defer.reject = reject; &#125;); return defer;&#125;;// module.exports = AjPromise;// new AjPromise((resolve, reject) =&gt; &#123;// setTimeout(() =&gt; &#123;// resolve(2);// &#125;, 2000);// &#125;)// .then(res =&gt; &#123;// console.log(res);// return res + 1;// &#125;)// .then(res =&gt; &#123;// console.log(res);// &#125;);// 循环引用// const promise = AjPromise.resolve()// .then(() =&gt; &#123;// return promise// &#125;)// promise.catch(console.error)AjPromise.resolve(1) .then((res) =&gt; &#123; console.log(res) return 2 &#125;) .catch((err) =&gt; &#123; return 3 &#125;) .then((res) =&gt; &#123; console.log(res) &#125;)]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise源码实现——版本一]]></title>
    <url>%2F2020%2F08%2F20%2FPromise%2FPromise%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171//Promise/A+规定的三种状态const PENDING = 'pending'const FULFILLED = 'fulfilled'const REJECTED = 'rejected'class MyPromise &#123; // 构造方法接收一个回调 constructor(executor) &#123; this._status = PENDING // Promise状态 this._value = undefined // 储存then回调return的值 this._resolveQueue = [] // 成功队列, resolve时触发 this._rejectQueue = [] // 失败队列, reject时触发 // 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue let _resolve = (val) =&gt; &#123; //把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况 const run = () =&gt; &#123; if(this._status !== PENDING) return // 对应规范中的"状态只能由pending到fulfilled或rejected" this._status = FULFILLED // 变更状态 this._value = val // 储存当前value // 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次" // 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调 while(this._resolveQueue.length) &#123; const callback = this._resolveQueue.shift() callback(val) &#125; &#125; setTimeout(run) &#125; // 实现同resolve let _reject = (val) =&gt; &#123; const run = () =&gt; &#123; if(this._status !== PENDING) return // 对应规范中的"状态只能由pending到fulfilled或rejected" this._status = REJECTED // 变更状态 this._value = val // 储存当前value while(this._rejectQueue.length) &#123; const callback = this._rejectQueue.shift() callback(val) &#125; &#125; setTimeout(run) &#125; // new Promise()时立即执行executor,并传入resolve和reject executor(_resolve, _reject) &#125; // then方法,接收一个成功的回调和一个失败的回调 then(resolveFn, rejectFn) &#123; // 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行 typeof resolveFn !== 'function' ? resolveFn = value =&gt; value : null typeof rejectFn !== 'function' ? rejectFn = reason =&gt; &#123; throw new Error(reason instanceof Error? reason.message:reason); &#125; : null // return一个新的promise return new MyPromise((resolve, reject) =&gt; &#123; // 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论 const fulfilledFn = value =&gt; &#123; try &#123; // 执行第一个(当前的)Promise的成功回调,并获取返回值 let x = resolveFn(value) // 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve x instanceof MyPromise ? x.then(resolve, reject) : resolve(x) &#125; catch (error) &#123; reject(error) &#125; &#125; // reject同理 const rejectedFn = error =&gt; &#123; try &#123; let x = rejectFn(error) x instanceof MyPromise ? x.then(resolve, reject) : resolve(x) &#125; catch (error) &#123; reject(error) &#125; &#125; switch (this._status) &#123; // 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行 case PENDING: this._resolveQueue.push(fulfilledFn) this._rejectQueue.push(rejectedFn) break; // 当状态已经变为resolve/reject时,直接执行then回调 case FULFILLED: fulfilledFn(this._value) // this._value是上一个then回调return的值(见完整版代码) break; case REJECTED: rejectedFn(this._value) break; &#125; &#125;) &#125; //catch方法其实就是执行一下then的第二个回调 catch(rejectFn) &#123; return this.then(undefined, rejectFn) &#125; //finally方法 finally(callback) &#123; return this.then( value =&gt; MyPromise.resolve(callback()).then(() =&gt; value), //执行回调,并returnvalue传递给后面的then reason =&gt; MyPromise.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) //reject同理 ) &#125; //静态的resolve方法 static resolve(value) &#123; if(value instanceof MyPromise) return value //根据规范, 如果参数是Promise实例, 直接return这个实例 return new MyPromise(resolve =&gt; resolve(value)) &#125; //静态的reject方法 static reject(reason) &#123; return new MyPromise((resolve, reject) =&gt; reject(reason)) &#125; //静态的all方法 static all(promiseArr) &#123; let index = 0 let result = [] return new MyPromise((resolve, reject) =&gt; &#123; promiseArr.forEach((p, i) =&gt; &#123; //Promise.resolve(p)用于处理传入值不为Promise的情况 MyPromise.resolve(p).then( val =&gt; &#123; index++ result[i] = val if(index === promiseArr.length) &#123; resolve(result) &#125; &#125;, err =&gt; &#123; reject(err) &#125; ) &#125;) &#125;) &#125; //静态的race方法 static race(promiseArr) &#123; return new MyPromise((resolve, reject) =&gt; &#123; //同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态 for (let p of promiseArr) &#123; MyPromise.resolve(p).then( //Promise.resolve(p)用于处理传入值不为Promise的情况 value =&gt; &#123; resolve(value) //注意这个resolve是上边new MyPromise的 &#125;, err =&gt; &#123; reject(err) &#125; ) &#125; &#125;) &#125;&#125;MyPromise.resolve() .then(function success (res) &#123; throw new Error('error') &#125;, function fail1 (e) &#123; console.error('fail1: ', e) &#125;) .catch(function fail2 (e) &#123; console.error('fail2: ', e) &#125;)]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[quicklink原理解析(二)]]></title>
    <url>%2F2020%2F07%2F29%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2Fquicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902%2F</url>
    <content type="text"><![CDATA[preload和prefetch的区别 preload 是告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源，prefetch 是告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源 Prefetch加载优先级非常低，也就是说该方式的作用是加速下一个页面的加载速度 Preload 的与众不同还体现在 onload 事件上。也就是说可以定义资源加载完毕后的回调函数 preload 和 prefetch 混用的话，并不会复用资源，而是会重复加载，使用 preload 和 prefetch 的逻辑可能不是写到一起，但一旦发生对用一资源 preload 或 prefetch 的话，会带来双倍的网络请求 大约有 50% 的支持度， 大约有 70% 的支持度。 as资源类型1&lt;link rel="prefetch" href="/my.little.script.js" as="script"&gt; as：1&lt;audio&gt;、 &lt;video&gt;、 &lt;script&gt;、 &lt;link rel=stylesheet&gt;、 &lt;img&gt;、 SVG、 XHR, fetch、 &lt;iframe&gt;、 HTML 可以看到，Prefetch的可选资源类型非常丰富，除了我们常用的script和style，甚至还包括iframe 、video、img等，基本涵盖了Web中的各类资源。 Prerenderprerender则是prefetch的更进一步。可以粗略地理解为“预处理”（预执行）。通过Prerender“预处理”的资源，浏览器都会作为HTML进行处理。浏览器除了会去获取资源，还可能会预处理（MAY preprocess）该资源，而该HTML页面依赖的其他资源，像&lt;script&gt;、&lt;style&gt;等页面所需资源也可能会被处理。但是预处理会由于浏览器或当前机器、网络情况的不同而被不同程度地推迟。例如，会根据CPU、GPU和内存的使用情况选择不同的策略或阻止该操作。 注意，由于这些预处理操作的不可控性，当你只是需要能够预先获取部分资源来加速后续可能出现的网络请求时，建议使用Prefetch。 Quicklink的预加载quicklink通过动态的创建link标签，再为其指定url要预加载一个资源可以通过下面四行代码： Resource Hints的兼容处理quicklink会判断是否支持 Resource Hints 中的 prefetch：link.relList.supports(feature)， dom对象有一个relList属性，它的supports方法可以检测是否支持prefetch 在不支持 Resource Hints 的浏览器中，使用其他方式来预加载资源，所以，quicklink利用浏览器自身的缓存策略，回退使用 XHR 加载，“实实在在”预先请求这个资源 预加载策略预加载方式：第一种：如果传入的options参数中有urls属性，则直接执行预加载urls数组内的资源第二种：通过document.querySelectorAll方法获取所有a标签元素的NodeList，然后遍历该元素节点列表，并监视该元素节点 有了资源预加载的方式，那么接下来就需要一个预加载的策略了。这其实是个见仁见智的问题。例如直接给你一个链接 https://my.test.com/somelink，在没有任何背景信息的情况下，恐怕你完全不知道是否需要预加载它。那对于这个问题，quicklink 是怎么解决的呢？或者说，quicklink 是通过什么策略来进行预加载的呢？quicklink 用了一个比较直观的策略：只对处于视口内的资源进行预加载。这一点也比较好理解，网络上大多的资源加载、页面跳转都伴随着用户点击这类行为，而它要是不在你的视野内，你也就无从点击了。这一定程度上算是个必要条件。这么一来，我们所要解决的问题就是，如何判断一个链接是否处于可视区域内？ intersectionobserverIntersectionObserver支持两个参数： callback是当被监听元素的可见性变化时，触发的回调函数 options是一个配置参数，可选，有默认的属性值 intersectionobserver的兼容处理Polyfill是一个js库，主要抚平不同浏览器之间对js实现的差异。比如window.XMLHttpRequest , 大多数浏览器支持，但IE不支持。Polyfill的典型做法是在IE浏览器中增加XHR对象，其内部实现还是使用 ActiveXObject，帮助将这些差异化抹平，不支持的变得支持了。Polyfill.io 读取每个请求的 User-Agent(UA) 头，并生成适合于该浏览器的 polyfill ，基于你的应用所使用的特性发回必要的代码，polyfill的使用：1.Features该参数指定需要 polyfill 的浏览器特性。多个特性名之间用逗号分隔。允许使用的特性明在 浏览器和特性 页中列出。2.Flagsalways - Polyfill 将始终被包含，不管 UA 中指出的浏览器是否已经支持该特性。gated - 通过特性检测来判断 Polyfill，只有在浏览器原生 API 不支持这些特性的情况下才返回并执行 Polyfill。 网络状态的获取Navigator.connection 是只读的，提供一个NetworkInformation 对象来获取设备的网络连接信息。1、downlink： 估算的下行速度/带宽 2、effectiveType： 当前的网络连接类型，其中effectiveType的取值可能是’slow-2g’、’2g’、’3g’或者’4g’。 3、onchange： 回调函数，在网络状态发生改变后执行 4、rtt ：估算的往返时间 5、saveData ：打开/请求数据保护模式 (conn.effectiveType || ‘’).includes(‘2g’) || conn.saveDataeffectiveType的取值可能是’slow-2g’、’2g’、’3g’或者’4g’ quicklink的实现总结 new 一个IntersectionObserver对象(提前引入polyfill做兼容)， 检测网页中的链接是否出现在视口中，等待链接出现在视口，执行步骤2。 使用requestIdleCallback等待浏览器空闲后（兼容则是自己模拟的一个setTimeOut），执行3。 判断当前的网络连接是否是2G或者数据保护模式，如果是则停止执行，直接return，如果不是，执行步骤4。 通过resource hint的prefetch或者XHR预加载链接指向的资源。]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[quicklink原理解析(一)]]></title>
    <url>%2F2020%2F07%2F20%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2Fquicklink%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%901%2F</url>
    <content type="text"><![CDATA[quicklink是什么？quicklink 是一个通过预加载资源来提升访问速度的轻量级工具库（压缩后&lt; 1KB）,通过提前加载资源，使浏览器加载缓存资源，从而减少请求所消耗的时间，来达到快速打开页面的目的。 How it works？ Waits until the browser is idle (using requestIdleCallback) Detects links within the viewport (using Intersection Observer) Checks if the user isn’t on a slow connection (using navigator.connection.effectiveType) or has data-saver enabled (using navigator.connection.saveData) Prefetches URLs to the links (using or XHR). Provides some control over the request priority (can switch to fetch() if supported). 如何确定浏览器是否空闲？如果浏览器支持requestIdleCallback，则使用原生的函数，如果不支持，则使用setTimeout函数做ployfill。 requestIdleCallback：它指定只有当一帧的末尾有空闲时间，才会执行回调函数。一般浏览器的刷新频率是60HZ，也就是说，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。requestIdleCallback(callback[, timeout]) callbackcallback会接收到一个名为callback deadline 的参数，它具有如下属性 :timeRemaining() 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于0，就把任务分配到下一轮requestIdleCallback。deadline对象的 didTimeout 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发 timeout如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。 requestIdleCallback 兼容处理如果浏览器支持requestIdleCallback，则使用原生的函数，如果不支持，则使用setTimeout函数做ployfill。 如何预加载指定资源？常见的是通过一些技术手段来实现资源的预加载，例如使用XMLHttpRequest来获取资源并进行缓存。然而，这些技术都是应用层面的，并非Web标准，某些需求也无法准确实现，同时，在性能方面也存在着问题。好在目前已有相关的Web标准——Resource Hint，通过它，可以在浏览器原生层面实现这些功能，同时提供性能保证。 Resource Hint有5种： DNS Prefetch Preconnect Preload Prefetch Prerender DNS PrefetchDNS解析：查找域名对应的ip，会耗费大量的时间，所以可以利用DNS预解析。 Resource Hint主要通过使用link标签。rel属性确定类型，href属性则指定相应的源或资源URL 。1&lt;link rel="dns-prefetch" href="//yourwebsite.com"&gt; Preconnect建立连接不仅需要DNS查询，还需要进行TCP协议握手，有些还会有TLS/SSL协议，这些都会导致连接的耗时。因此，使用Preconnect可以帮助你告诉浏览器：“我有一些资源会用到某个源，可以帮我预先建立连接。”1&lt;link rel="preconnect" href="//yourwebsite.com"&gt; Prefetch你可以把Prefetch理解为资源预获取。一般来说，可以用Prefetch来指定在紧接着之后的操作或浏览中需要使用到的资源，让浏览器提前获取。由于仅仅是提前获取资源，因此浏览器不会对资源进行预处理，并且像CSS样式表、JavaScript脚本这样的资源是不会自动执行并应用于当前文档的。在 Chrome 中，如果用户从一个页面跳转到另一个页面，prefetch 发起的请求仍会进行不会中断。另外，prefetch 的资源在网络堆栈中至少缓存 5 分钟，无论它是不是可以缓存的。 Preloadpreload 提供了一种声明式的命令，让浏览器提前加载指定资源(加载后并不执行)，需要执行时再执行这样做的好处在于：1、将加载和执行分离开，不阻塞渲染和document的onload事件2、提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出的情况 此外，preload 不会阻塞 windows 的 onload 事件 Preload的使用注意：对跨域的文件进行preload时，必须加上 crossorigin 属性没有用到的 preload 资源在 Chrome 的 console 里会在 onload 事件 3s 后发生警告 需要注意的是，和DNS Prefetch、Preconnect使用不太一样的地方是，Prefetch有一个as的可选属性，用来指定获取资源的类型。由于不同的资源类型会具有不同的优先级、CSP、请求头等，因此该属性很重要。 浏览器资源的优先级在Chrome浏览器中，不同的资源在浏览器渲染的不同阶段进行加载的优先级不同 一共分成五个级别 Highest 最高Hight 高Medium 中等Low 低Lowest 最低 其中主资源HTML和CSS的优先级最高，其他资源根据情况的不同优先级不一，JS脚本根据它们在文件中的位置是否异步、延迟或阻塞获得不同的优先级：1、网络在第一个图片资源之前阻塞的脚本在网络优先级中是中级2、网络在第一个图片资源之后阻塞的脚本在网络优先级中是低级3、异步／延迟／插入的脚本（无论在什么位置）在网络优先级中是很低级 图片（视口可见）将会获得相对于视口不可见图片（低级）的更高的优先级（中级），所以某些程度上 Chrome 将会尽量懒加载这些图片。低优先级的图片在布局完成被视口发现时，将会获得优先级提升 预加载 使用 “as” 属性加载的资源将会获得与资源 “type” 属性所拥有的相同的优先级。比如说，preload as=”style” 将会获得比 as=“script” 更高的优先级 不带 “as” 属性的 预加载 的优先级将会等同于异步请求，如果忽略 as 属性，或者错误的 as 属性会使 预加载 等同于 XHR 请求，浏览器不知道加载的是什么，因此会赋予此类资源非常低的加载优先级]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue模板编译器原理]]></title>
    <url>%2F2020%2F06%2F14%2Fvue%2FVue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[模板渲染流程 通过正则把模板转换成 AST 抽象语法树 优化器优化，标记所有的静态节点后，交由代码生成器生成渲染代码， 通过渲染函数构建器将渲染代码构建成一个渲染函数， 调用渲染函数，我们就可以得到目标模板的虚拟dom AST抽象树的结构AST的每个节点的结构如下：123456789&#123; tag: tagName, // 标签名 type: 1, // 元素类型 children: [], // 孩子列表 attrs, // 属性集合 parent: null, // 父元素 text: null // 文本节点内容 ...&#125; 节点类型有：元素类型、文本类型、注释类型… 生成AST抽象语法树模板引擎解析html字符串，每匹配到下面一种类型，就触发对应的钩子函数 是否是开始标签，如： ； 是否是结束标签，如： ; 是否是一段文本，如：这是一段代码中的文字； 是否是一个注释，如： 1234567891011121314parseHTML(html, &#123; start(tag, attrs, isUnary, startIndex, endIndex) &#123; // 收集整理信息 &#125;, end(tag, startIndex, endIndex) &#123; // 收集整理信息 &#125;, chars(text, startIndex, endIndex) &#123; // 收集整理信息 &#125;, comment(text, startIndex, endIndex) &#123; // 收集整理信息 &#125;,&#125; 从上面的代码可以看到，我们将模板字符串是否存在作为while的终止条件，我们每匹配到 一种情况，就会将相应的文本从html中删除掉，这样不断循环下去，就会不断的触发响应的钩子函数收集数据，直至html变成空字符串退出循环，此时，我们已经将整个文本都解析完了。 钩子函数start 根据传过来的标签名创建抽象语法树元素节点 检查一些非法属性或标签，并对一些特殊情况做预处理 解析attrs 解析指令v-if，v-for，v-once等 如果不是自闭标签的话，将当前元素加入到栈中，用于维护元素间的父子关系 钩子函数end 将栈顶元素弹出（因为当前标签已经结束后了，栈顶存的就是当前标签） 重新更正父级标签（因为当前标签已经结束，说明他的子节点也都解析完了，父标签不在是当前标签了，父级标签有重新变回当前标签的父级标签） 关闭标签，此时对if条件分支进行一些补充以及进行一些收尾工作等 钩子函数chars 创建抽象语法树文本节点 将这个文本节点加入到父节点的children中 钩子函数comment 创建抽象语法树注释节点 只要注释节点存在父级，就把注释节点加入到父级节点的children中 举个例子:1234567&lt;div&gt; &lt;p&gt;这是一段文字&lt;/p&gt; &lt;ul&gt; &lt;li&gt;选项1&lt;/li&gt; &lt;li&gt;选项2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 当我们解析到&lt;div&gt;时，将div加入到栈中，此时栈中只有div一个元素，然后继续解析，解析到&lt;p&gt;s的时候，我们再把p也加入到栈中，此时栈中有div和p两个元素，栈顶的元素是p。再往下解析，解析到一段文字，触发chars收集并生成抽象语法树文本节点，那么，此时，这个文本节点的父级是什么呢？显而易见，就是我们栈顶的元素p。所以我们将这个文本节点加入到p的children中即可。继续解析，发现&lt;/p&gt;结束标签，我们将栈顶元素p弹出来，也就是说，现在我们的栈里又只有一个div了，同理，下面的ul和li也是这样操作。当最后解析到&lt;/div&gt;时，栈里也就只有一个div元素了，将栈顶的div弹出，栈空了，已经解析完了。流程如下： 参考： Vue模板编译原理 Vue源码学习之模板编译器原理 HTMLParser 的实现和使用 模板引擎实现原理（Vue篇）]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈vue中key的作用]]></title>
    <url>%2F2020%2F06%2F12%2Fvue%2F%E6%B5%85%E8%B0%88vue%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[举一个例子例如：data数组从 [1,2,3] 变成了 [1,3]，也就是删除了中间的2，vue会如何处理？ v-for不加key注意看图中的绿色正方形没有被删除,原因很简单，你认为你删除了2，但Vue会认为你做了两件事：把2变成了3，然后把3删除了。所以发现，此时vue的diff对比的过程如下：首先对比 1 和 1，发现「1 没变」；然后对比 2 和 3发现「2 变成了 3」；最后对比 undefined 和 3，发现「3 被删除了」。 v-for加key注意，这次vue把中间的2删除了，diff的过程详情参考后续对diff算法介绍的文章，但简单的讲，就是会先对比：1.新头和旧头2.新尾和旧尾这里两步已经识别了，1，3相同，然后移动指针后移，发现对比结束，并删除多余的2[1,2,3]–&gt;[1,3] 为什么v-for不使用index做为key如果你用 index 作为 key，那么在删除第二项的时候，index 就会从 1 2 3 变成 1 2（因为 index 永远都是连续的，所以不可能是 1 3），那么 Vue 依然会认为你删除的是第三项。也就是会遇到上面一样的 bug。注意看官网中的demo，用的是data中的id，而不是v-for的index123&lt;div v-for="item in items" v-bind:key="item.id"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; v-if中的key用 key 管理可复用的元素：Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：12345678&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address"&gt;&lt;/template&gt; 那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，&lt;input&gt; 不会被替换掉——仅仅是替换了它的 placeholder这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可 v-for中的key当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute：123&lt;div v-for="item in items" v-bind:key="item.id"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。后面我们将在指南中看到，它还具有其它用途。 keykey 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。 最常见的用例是结合 v-for：123&lt;ul&gt; &lt;li v-for="item in items" :key="item.id"&gt;...&lt;/li&gt;&lt;/ul&gt; 它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用： 完整地触发组件的生命周期钩子 触发过渡例如：123&lt;transition&gt; &lt;span :key="text"&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt; 当 text 发生改变时， 总是会被替换而不是被修改，因此会触发过渡。 参考：https://www.zhihu.com/question/61064119/answer/766607894]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[merge--no-ff和--ff和--squash的区别]]></title>
    <url>%2F2020%2F02%2F01%2Fgit%2Fmerge-no-ff%E5%92%8C-ff%E5%92%8C-squash%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一张图来告诉你–no-ff和–ff git merge 我们平常什么都不加的时候，则使用默认的 –ff ， 即 fast-forward 方式 fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit git merge –no-ff1指的是强行关闭fast-forward方式,保留分支的commit历史 git merge –squash 是用来把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，那么我们合并的时候不希望把这些历史commit带过来，于是使用 动图来告诉几种合并的区别 举个例子 在master分支上，执行git merge hotfix然后看到了Fast-forward 的字样，hotfix通过–ff的方式合进了master，如下：仅仅是master指针指向了这个提交C4。这样是一种比较快的合并方式，轻量级，简单。这个时候，我们往往会删掉hotfix分支，因为它的历史作用已经结束，这个时候，我们的iss53这个功能又向前开发，进行了一次提交，到了C5，那么变成了这样：然后，我们要把iss53 这个分支合并回master，因为有分叉，两个版本的内容要进行合并,是不能用Fast-forward（只有在没有需要合并内容的时候，会有这个fast-forward 方式的提交） ，这时用的就是–no-ff的效果，并生成了一个新的commit号如果我们对第一次合并，使用了–no-ff参数，那么也会产生这样的结果，生成一个新的提交，实际上等于是对C4 进行一次复制，创建一个新的commit，这就是–no-ff的作用。 参考:“git merge”和”git merge–no ff”有什么区别？Git：git-merge的–ff和–no-ff]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git rebase和git merge的区别]]></title>
    <url>%2F2020%2F01%2F28%2Fgit%2Frebase%E5%92%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[假设有个开发过程如下：12341. master分支有两个commit：C1 -&gt; C22. 我基于master切一个dev分支进行开发3. dev分支在今天下午生成了3个commit，分别在：C3(2点)-&gt; C4(3点) -&gt; C5(6点)4. 同样在今天下午，其它开发者先于我在master分支上合入了自己的分支，C6(4点) -&gt; C7(5点)，所以远程的master就变成了C1 -&gt; C2 -&gt; C6(4点) -&gt; C7(5点) 如下图：15. 在7点，我想把我的dev分支合进master，有两种选择：merge和rebase 使用git merge123451. 在master上，执行`git merge dev`2. git会找出master和dev的最近共同祖先commit点，即分叉点C23. 然后进行合并，将dev最后1次的commit（C5）和master最后一次commit（C7）合并后生成一个新的commit（C8），有冲突的话需要解决冲突4. 再将C8和C2之间的所有commit，按提交时间顺序进行排序5. 最后生成的master：C1 -&gt; C2 -&gt;C3(2点)-&gt; C4(3点) -&gt; C6(4点) -&gt; C7(5点) -&gt; C5(6点) -C8(7点) 使用git rebase12341. 在dev分支上，执行`git rebase origin/master`，push到dev远程后，再去master分支，执行`git merge dev`2. 执行rebase时，git会找出master和dev的最近共同祖先commit点，即分叉点C23. 然后将dev分支上，C2到最后一次commit(C5)之间的所有commit截取，移接到master的最后一次commit(C7)后面，但截取的这一段(C3~C5的commit的hash值会变成新的，也就是变成了C3&apos;~C5&apos;)4. dev rebase了 master后，就变成了C1 -&gt; C2 -&gt; C6 -&gt; C7 -&gt; C3&apos; -&gt; C4&apos; -&gt; C5&apos; merge和rebase的区别 git merge 操作合并分支会让两个分支的每一次提交都按照提交时间（并不是push时间）排序，并且会将两个分支的最新一次commit点进行合并成一个新的commit，最终的分支树呈现菱形 git rebase操作实际上是将当前执行rebase分支的所有基于原分支提交点之后的commit打散成一个一个的patch，并重新生成一个新的commit hash值，再次基于原分支目前最新的commit点上进行提交，并不根据两个分支上实际的每次提交的时间点排序，rebase完成后，切到基分支进行合并另一个分支时也不会生成一个新的commit点，最终的分支树呈现线性]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue文档纪要]]></title>
    <url>%2F2020%2F01%2F20%2Fvue%2Fvue%E6%96%87%E6%A1%A3%E7%BA%AA%E8%A6%81%2F</url>
    <content type="text"><![CDATA[计算属性和侦听器计算属性计算属性的setter计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 现在再运行 vm.fullName = &#39;John Doe&#39; 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新 列表渲染用v-for把一个数组对应为一组元素1234567891011this.items = [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125;];&lt;li v-for="(item, index) in items"&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;&lt;/li&gt;// 渲染结果：// 0 - Foo,// 1 - Bar 在v-for里使用对象12345678910111213this.object = &#123; title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10'&#125;&lt;div v-for="(value, name, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;// 渲染结果// 1.title: 'How to do lists in Vue',// 2.author: 'Jane Doe',// 3.publishedAt: '2016-04-10' 深入了解组件组件注册组件名大小写我们强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)1Vue.component('my-component-name', &#123; /* ... */ &#125;) 自定义事件事件名不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：123456// 没有效果 &lt;my-component v-on:my-event="doSomething"&gt;&lt;/my-component&gt;this.$emit('myEvent');&lt;blog-post post-title="hello!"&gt;&lt;/blog-post&gt;props: ['postTitle'], 内在深入响应式原理检测变化的注意事项对于对象响应式与非响应式：12345678910var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应式的vm.b = 2// `vm.b` 是非响应式的 给对象添加单个新属性：用$set1this.$set(this.someObject,'b',2) 给对象添加多个新属性：直接Object.assign()不会触发响应，需要原对象与要混合进去的对象的 property 一起创建一个新的对象12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 对于数组Vue 不能检测以下数组的变动：1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue2.当你修改数组的长度时，例如：vm.items.length = newLength 但$set和数组的splice、shift等方法可以触发：12Vue.set(vm.items, indexOfItem, newValue);vm.items.splice(indexOfItem, 1, newValue); 异步更新队列nextTick：将回调延迟到下次 DOM 更新循环之后执行，下面是理解nextTick的很好的例子：1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // false,因为dom未更新Vue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true，因为dom已更新&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie篇]]></title>
    <url>%2F2019%2F11%2F21%2Fhttp%2Fcookie%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是cookie? 第一次访问服务器的时候，会在响应头里面看到Set-Cookie信息（只有在首次访问服务器的时候才会在响应头中出现该信息）,如：Set-Cookie:JSESSIONID=joadjosd 浏览器会根据响应头的set-cookie信息设置浏览器的cookie并保存到浏览器本地 当再次请求的时候（非首次请求），浏览器会在请求头里将cookie发送给服务器(每次请求都是这样)，如：将上面保存的 JSESSIONID=joadjosd 发给服务器 什么是JSESSIONID？ 当用户访问服务器的时候，服务器会为每一个用户开启一个session,浏览器是怎么判断这个session到底是属于哪个用户呢？JSESSIONID的作用就体现出来了：JSESSIONID就是用来判断当前用户对应于哪个session，换句话说JSESSIONID会告诉服务器该浏览器的session保存在服务器内存的什么地方。 服务器首先检查这个浏览器的请求里是否已包含了一个session标识————称为session id，如果已包含则说明以前已经为此浏览器创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个）；如果浏览器请求不包含session id，则为此浏览器创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给浏览器保存。 保存这个session id的方式可以采用cookie，这样浏览器在下次请求中，会把包含这个session id的cookie发送给服务器。 一般这个cookie的名字都是类似于SESSIONID，JSESSIONID只是tomcat的对session id的叫法，其实就是session id，在其它的容器也许就不叫JSESSIONID了。 创建cookie123function setCookie(name,value,cookieDomain) &#123; document.cookie = name + '='+ encodeURIComponent(value) + ';domain=' + cookieDomain + ';path=/';&#125; 删除cookie1234567// 删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可function delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cookie = getCookie(name); cookie &amp;&amp; (document.cookie = name + '=' + cookie + ';expires=' + exp.toGMTString()); &#125; cookie属性 属性项 属性项介绍 NAME=VALUE 键值对，可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样 Expires 过期时间，在设置的某个时间点后该 Cookie 就会失效 Domain 生成该 Cookie 的域名，如 domain=”www.baidu.com&quot; Path 该 Cookie 是在当前的哪个路径下生成的，如 path=/wp-admin/ Secure 如果设置了这个属性，那么只会在 SSH 连接时才会回传该 Cookie 参考：1.JSESSIONID的简单说明2.cookie、session、sessionid 与jsessionid3.深入理解Cookie4.javascript cookie]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法好文章]]></title>
    <url>%2F2019%2F10%2F12%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F%E7%AE%97%E6%B3%95%E5%A5%BD%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[JavaScript 数据结构与算法之美 - 十大经典排序算法汇总 前端动画演绎排序算法 JavaScript 数据结构与算法之美时间和空间复杂度 mustache js模板引擎 snabbdom虚拟dom库 pace js加载动画组件库 quicklink预加载]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用n来管理node版本]]></title>
    <url>%2F2019%2F03%2F08%2Fnode%2F%E4%BD%BF%E7%94%A8n%E6%9D%A5%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[业务项目比较多，老项目使用的node版本比较低，为了管理多个版本的node，可以使用n工具来管理n和nvm工具一样，但比它简洁 安装n1npm install -g n 下载特定版本的node12// 会下载node/10.6.0n 10.6.0 下载稳定版本1n stable 删除特定版本1n rm 10.6.0 切换版本123456n node/6.10.2 node/6.11.0 node/9.4.0o node/10.6.0 使用特定版本来执行文件1n use 10.6.0 index.js 若安装某个版本的node失败，发生1dyld: initializer function 0x0 not in mapped image for /usr/local/bin/node 删除/usr/local/n/versions/node下的所有node版本，然后重新使用n命令安装即可。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm和npx的区别]]></title>
    <url>%2F2019%2F03%2F08%2Fnode%2Fnpm%E5%92%8Cnpx%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[npmnpm是Node.js的软件包管理器，其目标是自动化的依赖性和软件包管理 npm 允许在package.json文件里面，使用scripts字段定义脚本命令 –save-dev 与 –save的区别 npm install X:会把X包安装到node_modules目录中不会修改package.json,之后运行npm install命令时，不会自动安装X npm install --save-dev *:使用此命令安装，会将依赖安装到devDependencies目录下，该目录下都是开发时需要的依赖,如npm install --save-dev gulp-uglify，安装了js的压缩包gulp-uglify，而压缩插件只在开发时使用，项目发布后不需要 npm install --save *:会将依赖安装到description目录下，该目录下都是发布后也需要的依赖，如vue这样的框架，项目发布后依然需要 简写-S与-D的区别1234// -S会安装再dependencies目录下npm i -S xxx// -D会安装在devDependencies目录下npm i -D xxx npxnpx是执行Node软件包的工具，它从 npm5.2版本开始，就与npm捆绑在一起。如果不能用，手动安装1npm install -g npx npm与npx执行命令对比： 12345678910111213// 免去了设置路径npx eslint --init// 若使用npm./node_modules/bin/eslint --init// 或者在package.json设置好scripts脚本 //&#123;// "scripts": &#123;// "eslint":"eslint --init"// &#125;//&#125; npm run eslint npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在 默认情况下，首先检查路径中是否存在要执行的包（即在项目中）； 如果存在，它将执行； 若不存在，意味着尚未安装该软件包，npx将安装其最新版本，然后执行它； 只执行，不安装(若未安装，会报错)1npx some-package --no-install]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https原理]]></title>
    <url>%2F2018%2F12%2F03%2Fhttp%2Fhttps%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[TCP/IP协议簇 TCP/IP协议簇是协议的集合，包含上图等协议，http协议就是它的一个子集；TCP/IP协议并不完全符合OSI的七层参考模型，它采用了4层的层级结构，如下图。 http协议处于应用层，当客户端发送http请求，为了便于传输，传输层（TCP协议）将应用层的http报文进行切割，并在各个报文上打上标记序号及端口号，转发给网络层（IP协议），网络层增加目的地——MAC地址后转发给链路层，这样发送网络的请求准备就齐全了；服务器端在链路层接收到数据，按顺序往上发送，一直到应用层，这样才算真正接收到http请求。 发送端在曾与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息，反之，服务器端在接收时会一层一层的去掉首部信息，这种把数据信息包装起来的方法叫做封装。 为了确认数据送到目标处，TCP协议采用了三次握手的策略，握手的过程中使用了TCP标志（flag）——SYN和ACK：发送端首先发送一个带有SYN的标志给对方，接收端收到后，发送一个SYN/ACK标志的数据包，表示确认收到，最后，发送端再发送一个ACK标志的数据包，代表“握手”结束。 http协议 HTTP协议（HyperText Transfer Protocol，超文本传输协议）：是客户端与Web服务器之间的应用层通信协议。 http协议的不足 通信使用明文（不加密），内容有可能被窃听 不验证通信双方的身份，有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 https协议 HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。 如上图，HTTPS 相比 HTTP 多了一层 SSL/TLS，位于应用层与TCP协议之间。 http请求劫持HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下： 加密算法 对称加密：加密和解密都是使用的同一个密钥——对称密钥。 非对称加密: 加密和解密使用不同的密钥——公钥、私钥，公钥和算法都是公开的，私钥是保密的，用公钥加密，就可以用私钥解密，反之亦然；但公钥是公开的（黑客也有公钥），如果私钥加密的信息被黑客截获，黑客同样可以使用公钥进行解密，获取其中的内容，所以使用非对称加密，通信双方通常有两套私钥和公钥，发消息的一方使用对方的公钥进行加密，接收消息的一方使用自己的私钥解密（所以私钥可以认为是个人身份的证明）；非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 消息摘要：消息摘要是哈希算法的一种，可以将消息哈希转换成一个固定长度的值唯一的字符串。值唯一的意思是不同的消息转换的摘要是不同的，并且能够确保唯一。该过程不可逆，即不能通过摘要反推明文（似乎SHA1已经可以被破解了，SHA2还没有。一般认为不可破解，或者破解需要耗费太多时间，性价比低）。 数字签名： 签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过;hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改,举例如下：假设现在有通信双方A和B，两者之间使用两套非对称加密机制,现在A向B发消息:那么，如果在发送过程中，有人修改了里面密文消息，B拿到的密文，解密之后得到明文，并非A所发送的，信息不正确。要解决两个问题：1. A的身份认证 2. A发送的消息完整性 那么就要用到上面所讲的基础知识。数字签名的过程如下图：简单解释：A：将明文进行摘要运算后得到摘要（消息完整性），再将摘要用A的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给B。B：收到A的消息后，先将密文用自己的私钥解密，得到明文。将数字签名用A的公钥进行解密后，得到正确的摘要（解密成功说明A的身份被认证了）。对明文进行摘要运算，得到实际收到的摘要，将两份摘要进行对比，如果一致，说明消息没有被篡改（消息完整性）。疑问：摘要使用A的私钥加密，如果被拥有A的公钥的第三者截获，不就可以获取到摘要了么，会不会对安全造成威胁？答：不会，因为摘要是不可逆推出原文的。 HTTP 向 HTTPS 演化使用对称加密若对传输的信息加密,这样即使黑客截获，也无法破解此种方式属于对称加密，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是： 因为双方都要有密钥，所以若是客户端有了一个密钥，如何安全地给服务器也传送一把 客户端、服务器数量多，安全级别也不同，密钥极易泄露 所以试一试非对称加密 使用非对称加密如上图所示，它只使用了一套公钥和私钥，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，同理，服务器使用私钥加密，客户端可以使用公钥解密，所以缺点就出来了：公钥是公开的（也就是黑客也会有公钥），所以第4步是不安全的，如果私钥加密的信息被黑客截获，黑客同样可以使用公钥进行解密，获取其中的内容。 但第3步是安全的，所以可以利用非对称加密的第3步，再结合对称加密的方式，一起实现加密。 对称与非对称加密的结合 第3步使用的是非对称加密，客户端用公钥加密，将对称加密算法和对称密钥传输给了服务器 服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥，这时客户端和服务器端都有了对称密钥 从第4步开始，双方都使用对称加密进行通信 这种方式的问题： 客户端如何获得公钥 如何确认服务器是真实的而不是黑客 所以有了数字证书，服务器需要申购SSL证书 SSL证书校验如上图所示，在第2步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有： 证书的发布机构CA 证书的有效期 公钥 证书所有者 签名… 客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下： 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验 浏览器的”证书管理器”，有”受信任的根证书颁发机构”列表,客户端会根据这张列表，比对服务器发来的证书中的颁发者CA，校验证书是否为合法机构颁发 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。 如果找到，那么浏览器就会从操作系统中取出颁发者CA的公钥，然后对服务器发来的证书里面的签名进行解密 浏览器使用相同的摘要算法计算出服务器发来的证书的摘要，将这个计算的摘要与证书签名解密出的摘要做对比 对比结果一致，则证明服务器发来的证书合法，没有被冒充 此时浏览器就可以读取证书中的公钥，用于后续加密了 所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成所以相比HTTP，HTTPS 传输更加安全 所有信息都是加密传播，黑客无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 总结综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。HTTPS 缺点： SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐 HTTPS 降低用户访问速度（多次握手） 网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转） HTTPS 涉及到的安全算法会消耗 CPU 本文转载自 HTTPS 加密算法原理详解，增加了少量自己的归纳、理解参考： 《图解HTTP协议》 数字签名原理简介]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你想知道的BFC]]></title>
    <url>%2F2018%2F11%2F25%2Fcss%2F%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84BFC%2F</url>
    <content type="text"></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入——call、apply和bind的底层实现]]></title>
    <url>%2F2018%2F06%2F16%2F%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%2Fcall-apply-bind%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[call、apply和bind的区别 三者都是this的绑定，第一个参数都需要传入要绑定的this call和apply的区别是后面的参数，call是一个一个传入，而apply是通过一个数组传入 bind会返回一个函数，在需要的地方执行该函数；而call、apply会立即执行 call的Polyfill函数都可以调用 call，说明 call 是函数原型上的方法，所有的实例都可以调用。即: Function.prototype.call call的实现需要注意以下几点： 在 call 方法中获取调用call()函数 第一个参数可以不传或传null，此时this默认指向 window 从第二个参数起，可以向call传入不定长的参数 传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj;因此我们可以这样调用函数 context.fn(…args),即在上下文对象添加要执行的fn 执行完毕，delete添加的fn属性 Polyfill:123456789101112131415Function.prototype.call2 = function() &#123; // 初始化绑定的this对象(context)和参数args let [context, ...args] = [...arguments]; // args没传或传null，绑定window !context &amp;&amp; (context = window); // 将要执行的函数，绑定到context的fn属性上 context.fn = this; // 执行fn let result = context.fn(...args); // 删除多余添加的属性 delete context.fn; // 返回结果 return result;&#125; 测试一下：123456789101112131415// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call2(foo, 'kevin', 18);// kevin// 18// 1 bind2的测试没问题了，就可以把它放进prototype.bind，Polyfill的写法：123456if (!Function.prototype.bind)(function()&#123; Function.prototype.bind = function() &#123; ... &#125;&#125;)(); apply的Polyfillapply与call的实现，只有取参数的方式不同123456789Function.prototype.apply2 = function(context, args) &#123; !context &amp;&amp; (context = window); context.fn = this; let result = args ? context.fn(...args) : context.fn(); delete context.fn; return result;&#125; 测试一下：123456789101112131415// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.apply2(foo, ['kevin', 18]); // kevin// 18// 1 bind的Polyfillbind和call的区别就是，返回一个函数，在这个函数里执行fn123456789101112Function.prototype.bind2 = function() &#123; let [context, ...args] = [...arguments]; !context &amp;&amp; (context = window); context.fn = this; return function() &#123; let result = context.fn(...args); delete context.fn; return result; &#125;;&#125; 测试一下：12345678910111213141516// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;var func = bar.bind2(foo, 'kevin', 18); func();// kevin// 18// 1 也可以参考MDN的Polyfill]]></content>
      <categories>
        <category>前端深入</category>
      </categories>
      <tags>
        <tag>前端深入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git reset、--soft、--hard的区别]]></title>
    <url>%2F2018%2F06%2F13%2Fgit%2Fgit%E7%9A%84reset%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1git reset [--soft | --mixed | --hard] 为了简单，不用工作区和暂存区描述，用红色文件和绿色文件描述 git resetgit reset 不加参数，默认是–mixed git会回到指定的commit，并将两个commit之间的所有diff保留下来（红色文件） 利用这个特性，在合master前，feature分支的commit太多，希望合成一个12345// 回到最初的commitgit reset xxxxx// 重新提一个commitgit add -Agit commit -m '新功能xxx' ☑️ Squash commits when merge request is accepted.其实提MR时，勾选这个，就能合并所有的commit git reset –hardgit 会回到指定的commit，但两个commit之间的所有diff都被删除，干干净净的回到指定commit（如果执行这个命令之前就有被修改的红色文件，执行之后也会被删除） git reset –softgit会回到指定的commit，并将两个commit之间的所有diff保留下来，但不会变成红色文件，而是变成绿色文件（执行命令之前的红色文件修改，依然保留下来为红色）]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存机制]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%BC%93%E5%AD%98%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[HTTP缓存机制 当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源： 200 from memory cache不访问服务器，直接读缓存，从内存中读取缓存,此时的数据时缓存到内存中的，当页面被关闭以后，数据将不存在。 200 from disk cache不访问服务器，直接读缓存，从磁盘中读取缓存，当页面或浏览器关闭后，数据还是存在。 304 (Not Modified) 缓存过期，但Last-Modified、Etag验证资源有效，服务器返回304 缓存需要强制验证，确定资源有效后，服务器返回304，如：Cache-Control：no-cach（这个设置规定缓存前必须先确定有效性） 具体描述： 本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器； 协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源； 缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本地缓存中没有找到资源)，服务器则返回该资源的数据，并且返回200 协商缓存阶段Last-Modified &amp; if-modified-since Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。last-modified是WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间。 ETag &amp; If-None-Match ETag与If-None-Match是一对报文，属于http 1.1。ETag是一个文件的唯一标志符,就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化,如果请求资源的ETag与服务器的不一致，则表示该资源已经被修改过来，需要发最新的内容给浏览器。 Etag/lastModified过程如下： 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个Last-Modified/ETag。 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。 注意：通过If-Modified-Since和If-Match判断资源是否修改，如未修改则返回304，发生了一次请求，但请求内容长度为0，节省了带宽，如果有多台负载均衡的服务器，不同服务器计算出的Etag可能不同，这样就会造成资源的重复加载。 Etag主要为了解决Last-Modified无法解决的一些问题： 一些文件如果改变后，又改回来了，Last-Modified会认为文件修改过，但其实它是没有变化的，Etag就不会判定它变化了 If-Modified-Since能检查到文件的变化是秒级别的，但如果一个文件1秒内变化了好几次，If-Modified-Since就检测不出来，这时需要Etag检测 某些服务器不能精确的得到文件的最后修改时间 本地缓存阶段Expires和Cache-Control是需要在服务器端配置的 Expires 指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires。如果expires到期需要重新请求。 Cache-Control Cache-Control:这个是http 1.1中为了弥补 Expires 缺陷新加入的，下面是常用的值： no-cache：强制浏览器在使用cache之前，先提交一个http请求到源服务器进行确认资源是否有效，防止从缓存中获取的是无效的资源。虽然http请求并未减少，但返回的是一个空的请求体，这样相当于减少了一个响应体。 no-store：no-store规定了浏览器不缓存任何缓存，而no-cache只是不缓存无效（这里是无效不是过期）的资源。如下图：资源Expires已失效，也设置了no-cach,但浏览器还是缓存了过期的资源(304可以证明已缓存)，因为服务器判断了If-Modified-Since，资源是没有改动过的，所以返回了304。 max-age:指定多少秒后缓存过期，如Cache-Control: max-age=3600, must-revalidate（3600秒后过期） must-revalidate: 强制浏览器严格遵守你设置的cache规则。 proxy-revalidate: 强制proxy严格遵守你设置的cache规则。 参考： 缓存策略 详解浏览器缓存机制与Apache设置缓存 由memoryCache和diskCache产生的浏览器缓存机制的思考]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack使用指南]]></title>
    <url>%2F2018%2F05%2F07%2Fwebpack%2Fwebpack%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[创建package.json1npm init 在项目的根目录中执行这个命令，它会自动创建 package.json文件，然后终端会问诸如项目名称，项目描述，作者等信息，可默认回车 安装Webpack依赖包1npm install --save-dev webpack 这时package.json里会增加两个属性：description和devDependencies –save-dev 与 –save的区别 npm install X:会把X包安装到node_modules目录中不会修改package.json,之后运行npm install命令时，不会自动安装X npm install --save-dev *:使用此命令安装，会将依赖安装到devDependencies目录下，该目录下都是开发时需要的依赖,如npm install --save-dev gulp-uglify，安装了js的压缩包gulp-uglify，而压缩插件只在开发时使用，项目发布后不需要 npm install --save *:会将依赖安装到description目录下，该目录下都是发布后也需要的依赖，如vue这样的框架，项目发布后依然需要 -S与-D的区别1234// -S会安装再dependencies目录下npm i -S xxx// -D会安装在devDependencies目录下npm i -D xxx 简单的demo src/index.js 1document.getElementById('title').innerHTML = 'hello webpack'; dist/index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="title"&gt;&lt;/div&gt;&lt;script src="./js/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789// var path = require('path');module.exports = &#123; entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', // path: path.resolve(__dirname, 'dist'), filename: 'js/bundle.js' &#125;&#125; 注：__dirname是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 执行webpack，/dist/目录下会打包生成js/bundle.js,同时出现警告： 警告提示mode没有定义，这是 webpack 4x 引入的，有两个值，development 和 production，默认是production，可以用下面这两种方式指定： 执行webpack --mode development，而不是执行webpack 在webpack.config.js中指定mode属性，如：12345678module.exports = &#123; mode: 'development', entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', filename: 'js/bundle.js' &#125;&#125; 配置命令通过在package.json中配置script，如：123"scripts": &#123; "build": "webpack --mode development"&#125; 就可以用命令 npm run build 替代 webpack --mode development Source MapsSource Maps可以使调试更方便，当定位错误时，可以使编译文件与源文件一一对应，通过配置webpack.config.js中的devtool属性12345678module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', filename: 'js/bundle.js' &#125;&#125; devtool有4个值，优缺点如下： devtool选项 配置结果 source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度 cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便 eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项 cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点 使用webpack构建本地服务器Webpack提供了一个可选的本地开发服务器，可以让浏览器监听你的代码修改，并自动刷新显示修改后的结果这个本地服务器基于node.js构建，它是一个单独的组件，在webpack.config.js中配置前，需要单独安装 npm install --save-dev webpack-dev-server 然后配置devServer属性： 12345678910111213module.exports = &#123; entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', filename: 'js/bundle.js' &#125;, devServer: &#123; contentBase: "./dist",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true,//实时刷新 port: 8080//设置默认监听端口，如果省略，默认为”8080“ &#125;&#125; 在package.json中的scripts对象中添加如下命令，用以开启本地服务器： 123"scripts": &#123; "server": "webpack-dev-server --open"&#125; 在终端中输入 npm run server即可在本地的8080端口查看结果]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建git服务器]]></title>
    <url>%2F2017%2F09%2F13%2Fgit%2F%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[ubuntu安装git123456// 安装sudo apt-get install git// git仓库配置git config --global user.name "Your Name"git config --global user.email "email@example.com" 在Ubuntu上创建git用户1sudo adduser git 这样在/home目录下就多了一个git目录 在git用户下创建.ssh 目录1234cd /home/gitmkdir .sshcd .sshvi authorized_keys 将本地~/.ssh 里的id_rsa.pub中的内容添加到服务器端的authorized_keys 初始化一个git仓库在opt下建一个git目录，以后git的仓库都放在这个目录12345cd /optmkdir gitchown -R git:git git //修改git目录的拥有者chmod 777 gitcd git // chown将指定文件的拥有者改为指定的用户或组chown -R 用户名:组名 文件 初始化一个project仓库，一般以.git结尾进行命名123mkdir project.git cd project.gitgit --bare init 本地进行代码推送1234567# 在 本地 的电脑上cd myprojectgit initgit add .git commit -m 'initial commit'git remote add origin git@gitserver:/opt/git/project.gitgit push origin master 若因权限问题推送失败，则可能是文件夹所有者问题12# 修改服务器project.git仓库的所有者chown -R git:git project.git node 安装 去node官网，找到对应版本链接 wget https://nodejs.org/dist/v10.15.0/node-v10.15.0-linux-x64.tar.xz mv到对应目录，如/opt/ 解压 12tar -xvf node-v10.15.0-linux-x64.tar.xzmv node-v10.15.0-linux-x64.tar.xz nodejs 确认一下nodejs下bin目录是否有node 和npm文件，如果有则执行软连接，变为全局 12ln -s /opt/nodejs/bin/npm /usr/local/bin/ ln -s /opt/nodejs/bin/node /usr/local/bin/]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用技巧]]></title>
    <url>%2F2017%2F08%2F12%2Fgit%2Fgit%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[git push –set-upstream新建一个分支NAME后，直接执行git push到远程，是push不上去的 要么就是暴力推上去git push origin NAME, 若用下面这个建立远程关联，以后就能用git push了1git push --set-upstream origin NAME git push12// 提交本地test分支 作为 远程的master分支git push origin test:master git rebase12345678// 相当于是从远程获取最新版本到本地，不会自动mergegit fetch// 把b分支合并到当前分支git rebase b // 如：将远程的origin/master，合到本地分支git rebase origin/master 提mr时，合master有冲突1234567891011git checkout -b &lt;分支名&gt; origin/&lt;分支名&gt;git checkout mastergit pull --rebase=truegit checkout &lt;分支名&gt;# 合并mastergit merge master --no-ff# 解决冲突后，git add -Agit commit -m &lt;合并信息&gt;git push origin &lt;分支名&gt;:&lt;分支名&gt; 文件回退到指定版本12345// 会把文件变成绿色 + 红色git reset xxxx file// 对红色进行checkout恢复，就只剩绿色了，但文件已经变回指定版本了git checkout file// 若想让绿色变成红色，继续reset操作 回退到某个版本详细请看123git reset abcsdgit reset --hard abcsdgit reset --soft abcsd git reflog 回退到某个操作1234// 通过reflog找到操作的commitgit reflog// 回到那个commitgit reset 回退到上一个版本上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~1001git reset --hard HEAD^ git diff123456// 查看当前修改了啥git diff// 和某个commit做diffgit diff 276bb8f// 和某个文件做diffgit diff index.html 查看分支合并图1git log --graph 基于某个分支创建新分支12345678// 基于当前分支创建新分支devgit checkout -b dev// 基于远程分支，创建新分支git checkout -b &lt;分支名&gt; origin/&lt;分支名&gt;// 如：本地没有 develop-test，基于远程创建一个develop-testgit checkout -b develop-test origin/develop-test 分支查看本地分支：git branch 查看远程分支：git branch -a 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; git stash查看工作现场：git stash list 恢复现场但不删除stash：git stash apply 删除stash：git stash drop 恢复现场并删除stash：git stash pop]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[package.json和package-lock.json的区别]]></title>
    <url>%2F2017%2F08%2F11%2Fnode%2Fpackage-json%E5%92%8Cpackage-lock-json%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[package.jsonpackage.json文件记录项目中所需要的所有模块 当你执行 npm i时，nodeJS会从你的package.json中读取所有的dependencies信息，package.json文件只记录你通过npm install方式安装的模块信息，而这些模块所依赖的其他子模块的信息不会记录。 package-lock.jsonpackage-lock.json文件锁定所有模块的版本号(包括主模块和所有依赖子模块) package.json文件只能锁定大版本，即版本号的第一位，不能锁定后面的小版本，你每次npm install时候拉取的该大版本下面最新的版本。所以为了稳定性考虑我们不能随意升级依赖包，而package-lock.json就是来解决包锁定不升级问题的。 从npm 5.x开始，项目中采用package-lock.json的方式来锁定依赖的方式来排除自动升级问题，原则上不允许删除以及不允许放入到.gitignore与.npmignore中。 为什么会有lock呢？“锁定依赖”。小王做一个项目，里边用到了node-sass，package.json文件里会有引用：“node-sass”: “^4.9.3”，假设4.9.3是最新版，发版之后，node-sass更新到4.9.4，这时，小张需要修改小王的项目，拉取代码，install，这时，小张拉取的项目的node-sass的版本会自动更新到大版本下的最新版4.9.4，可能这个版本会影响我们之前的功能，就有问题了。这时，lock文件就出现了，npm 5以上install都是走的lock文件版本，只要不是手动更新组件版本，都是不会自动更新依赖的，这就保证了应用程序依赖之间的关系是一致的，兼容的。 升级package-lock.json如果要升级package-lock.json里面的库包，怎么操作呢？123npm install packageName // 或 npm install packageName@x.x.x ^和~的区别这里举个例子：12345"dependencies": &#123; "classnames": "2.2.5", // 表示安装2.2.5的版本 "antd": "^3.1.4", // 表示安装3.1.4及以上的版本，但是不安装4.0.0 "babel-plugin-import": "~1.1.0", // "~1.1.0",表示安装1.1.x的最新版本（不低于1.1.0），但是不安装1.2.x&#125;, 指定版本：比如”classnames”: “2.2.5”，表示安装2.2.5的版本 波浪号~+指定版本：比如 “babel-plugin-import”: “~1.1.0”,表示安装1.1.x的最新版本（不低于1.1.0），但是不安装1.2.x，也就是说安装时不改变大版本号和次要版本号 ^+指定版本：比如 “antd”: “^3.1.4”,，表示安装3.1.4及以上的版本，但是不安装4.0.0，也就是说安装时不改变大版本号。 大多数情况这种向新兼容依赖下载最新库包的时候都没有问题，可是因为npm是开源世界，各库包的版本语义可能并不相同，有的库包开发者并不遵守严格这一原则：相同大版本号的同一个库包，其接口符合兼容要求。这时候用户就很头疼了：在完全相同的一个nodejs的代码库，在不同时间或者不同npm下载源之下，下到的各依赖库包版本可能有所不同，因此其依赖库包行为特征也不同有时候甚至完全不兼容。 因此npm最新的版本就开始提供自动生成package-lock.json功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊:变量,作用域与内存]]></title>
    <url>%2F2017%2F06%2F23%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F%E8%81%8A%E4%B8%80%E8%81%8A-%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[数据类型js数据类型分两种： 基本数据类型：Undefined、 Null、 String、 Boolean、 Number、 String 和 Symbol(ES6新增) 复杂数据类型：Object 区别：内存的分配不同 基本数据类型存储在栈中 复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址 区分数据类型的方法： typeof：可以确定值是否是基本数据类型 instanceof：可以确定值是否是引用数据类型用 12typeof null // objectnull instanceof Object // false 区分数组和Object12// [Object, objct]、[Object, array]Object.prototype.toString.call() null是一个对象吗？ 另外尽管 typeof null === &#39;object&#39;,但null 不是一个对象，这是一个历史遗留问题，JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，null 表示为全零，所以将它错误的判断为 object 。 作用域链 内部上下文可以通过作用域链访问外部上下文的一切，但外部上下文无法访问内部上下文中的东西。找一个变量，如果在局部找到，则搜索停止；否则，继续沿着作用域链向上搜（作用域链中的对象有原型链，因此搜索也可能涉及每一个对象的原型链），这个过程一直延续到全局上下文的变量对象；若仍找不到，则未声明。 js执行上下文执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 执行上下文分全局上下文、函数上下文和块级上下文 JS执行上下文栈(后面简称执行栈)执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。 规则如下：首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。 以一段代码具体说明： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3();&#125;function fun1() &#123; fun2();&#125;fun1(); Global Execution Context (即全局执行上下文)首先入栈，过程如下：伪代码:12345678910111213141516171819202122//全局执行上下文首先入栈ECStack.push(globalContext);//执行fun1();ECStack.push(&lt;fun1&gt; functionContext);//fun1中又调用了fun2;ECStack.push(&lt;fun2&gt; functionContext);//fun2中又调用了fun3;ECStack.push(&lt;fun3&gt; functionContext);//fun3执行完毕ECStack.pop();//fun2执行完毕ECStack.pop();//fun1执行完毕ECStack.pop();//javascript继续顺序执行下面的代码，但ECStack底部始终有一个 全局上下文（globalContext）; 参考 块级作用域的概念 由最近的一对{}界定 var、let 和 const var存在变量的提升 let也存在变量的提升，但因存在“暂时性死区”，故不能在声明前使用let变量 let与var不同在于，同一作用域内let不能重复声明，let有块级作用域；let在全局作用域声明的变量不会成为window的属性 const和let基本相同，除了一点，声明时必须初始化变量，且不能修改；但可以修改const对象的属性（const a = Object.freeze({})可以冻结） js变量是松散类型，意思是可以保存任何类型的数据 内存管理优化内存的手段： 数据不再用，赋值null，释放其引用 let和const有块级作用域，有助于垃圾回收]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端基础---位运算]]></title>
    <url>%2F2017%2F04%2F25%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[通过一道题来回顾下位运算两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 示例:12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 答案：1234567891011121314var hammingDistance = function(x, y) &#123; var count = 0; while(x !== 0 || y !== 0) &#123; // 1001 // 0001 // x &amp; 1,其实比较的是x的最后一位数， if((x &amp; 1) !== (y &amp; 1)) &#123; ++count; &#125; x = x &gt;&gt; 1; y = y &gt;&gt; 1; &#125; return count;&#125;; 思路其实很简单：遍历两个数值，位数不相同那么 +1 负值如何用二进制表示通过3个步骤得到： 确定绝对值的二进制表示（如-18，先确定18的二进制表示） 找到每一位数值的补数，也就是，每个0变1，1变0 给结果+1 有符号的整数有符号的整数：第32位是符号位，如0表示正，1表示负；使用剩余的31位表示数值大小。 位运算规则12345&amp; : 按二进制位进行 与运算，相同位同时为 1 时结果为 1，否则为 0| : 按二进制位进行 或运算，相同位有一个为 1 时结果为 1，否则为 0^ : 按二进制位进行 异或运算，相同位相同时结果为 0，否则为 1&gt;&gt; : 右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位用符号位来补&lt;&lt; : 左移运算是将一个二进制位的操作数按指定移动的位数向左移位，移出位被丢弃，右边的空位一律补 0 将-5右移1位123var x = -5;x &gt;&gt;= 1;// -3 发生了如下12345678910111213// 如：-5// 1.找到5000...101// 2.找补数111...010// 3.补数+1,得到-5111...011// 4.右移1位1111..101// 5.减一1111..100// 6.取反，-3（符号位跟以前一样）0000..011]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
  </entry>
</search>
