<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[glob.sync]]></title>
    <url>%2F2020%2F11%2F10%2Fglob-sync%2F</url>
    <content type="text"><![CDATA[异步匹配和同步匹配1234// 异步匹配glob(pattern, [options], cb)// 同步匹配glob.sync(pattern, [options])]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue文档纪要]]></title>
    <url>%2F2020%2F10%2F20%2Fvue%E6%96%87%E6%A1%A3%E7%BA%AA%E8%A6%81%2F</url>
    <content type="text"><![CDATA[计算属性和侦听器计算属性计算属性的setter计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 现在再运行 vm.fullName = &#39;John Doe&#39; 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新 列表渲染用v-for把一个数组对应为一组元素1234567891011this.items = [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125;];&lt;li v-for="(item, index) in items"&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;&lt;/li&gt;// 渲染结果：// 0 - Foo,// 1 - Bar 在v-for里使用对象12345678910111213this.object = &#123; title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10'&#125;&lt;div v-for="(value, name, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;// 渲染结果// 1.title: 'How to do lists in Vue',// 2.author: 'Jane Doe',// 3.publishedAt: '2016-04-10' 深入了解组件组件注册组件名大小写我们强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)1Vue.component('my-component-name', &#123; /* ... */ &#125;) 自定义事件事件名不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：123456// 没有效果 &lt;my-component v-on:my-event="doSomething"&gt;&lt;/my-component&gt;this.$emit('myEvent');&lt;blog-post post-title="hello!"&gt;&lt;/blog-post&gt;props: ['postTitle'], 内在深入响应式原理检测变化的注意事项对于对象响应式与非响应式：12345678910var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应式的vm.b = 2// `vm.b` 是非响应式的 给对象添加单个新属性：用$set1this.$set(this.someObject,'b',2) 给对象添加多个新属性：直接Object.assign()不会触发响应，需要原对象与要混合进去的对象的 property 一起创建一个新的对象12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 对于数组Vue 不能检测以下数组的变动：1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue2.当你修改数组的长度时，例如：vm.items.length = newLength 但$set和数组的splice、shift等方法可以触发：12Vue.set(vm.items, indexOfItem, newValue);vm.items.splice(indexOfItem, 1, newValue); 异步更新队列nextTick：将回调延迟到下次 DOM 更新循环之后执行，下面是理解nextTick的很好的例子：1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // false,因为dom未更新Vue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true，因为dom已更新&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法好文章]]></title>
    <url>%2F2020%2F10%2F12%2F%E7%AE%97%E6%B3%95%E5%A5%BD%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[1.JavaScript 数据结构与算法之美 - 十大经典排序算法汇总2.前端动画演绎排序算法3.JavaScript 数据结构与算法之美 - 时间和空间复杂度]]></content>
  </entry>
  <entry>
    <title><![CDATA[pace.js原理解析]]></title>
    <url>%2F2020%2F08%2F08%2Fpace-js%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.看源码先从init()入手2.init()后，执行了Pace.start()方法3.Pace.go performance.now]]></content>
  </entry>
  <entry>
    <title><![CDATA[看了必懂的Promise源码分析]]></title>
    <url>%2F2020%2F04%2F27%2F2020-04%2F%E7%9C%8B%E4%BA%86%E5%BF%85%E6%87%82%E7%9A%84Promise%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目1.123456789const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve() console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4) 题目2.12345678910111213141516const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success') &#125;, 1000)&#125;)const promise2 = promise1.then(() =&gt; &#123; throw new Error('error!!!')&#125;)console.log('promise1', promise1)console.log('promise2', promise2)setTimeout(() =&gt; &#123; console.log('promise1', promise1) console.log('promise2', promise2)&#125;, 2000) 题目3.12345678910111213const promise = new Promise((resolve, reject) =&gt; &#123; resolve('success1') reject('error') resolve('success2')&#125;)promise .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;) 题目4.1234567891011Promise.resolve(1) .then((res) =&gt; &#123; console.log(res) return 2 &#125;) .catch((err) =&gt; &#123; return 3 &#125;) .then((res) =&gt; &#123; console.log(res) &#125;) 题目5.1234567891011121314const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('once') resolve('success') &#125;, 1000)&#125;)const start = Date.now()promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;)promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;) 题目6.12345678910Promise.resolve() .then(() =&gt; &#123; return new Error('error!!!') &#125;) .then((res) =&gt; &#123; console.log('then: ', res) &#125;) .catch((err) =&gt; &#123; console.log('catch: ', err) &#125;) 题目7.12345const promise = Promise.resolve() .then(() =&gt; &#123; return promise &#125;)promise.catch(console.error) 题目8.1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 题目9.123456789Promise.resolve() .then(function success (res) &#123; throw new Error('error') &#125;, function fail1 (e) &#123; console.error('fail1: ', e) &#125;) .catch(function fail2 (e) &#123; console.error('fail2: ', e) &#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用n来管理node版本]]></title>
    <url>%2F2020%2F03%2F08%2F%E4%BD%BF%E7%94%A8n%E6%9D%A5%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[业务项目比较多，老项目使用的node版本比较低，为了管理多个版本的node，可以使用n工具来管理n和nvm工具一样，但比它简洁 安装n1npm install -g n 下载特定版本的node12// 会下载node/10.6.0n 10.6.0 下载稳定版本1n stable 删除特定版本1n rm 10.6.0 切换版本123456n node/6.10.2 node/6.11.0 node/9.4.0o node/10.6.0 使用特定版本来执行文件1n use 10.6.0 index.js 若安装某个版本的node失败，发生1dyld: initializer function 0x0 not in mapped image for /usr/local/bin/node 删除/usr/local/n/versions/node下的所有node版本，然后重新使用n命令安装即可。]]></content>
      <categories>
        <category>node</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[babel精通1]]></title>
    <url>%2F2019%2F11%2F26%2Fbabel%E7%B2%BE%E9%80%9A1%2F</url>
    <content type="text"><![CDATA[babel的主要功能 转译语法 Polyfill浏览器不具备的features]]></content>
  </entry>
  <entry>
    <title><![CDATA[babel6升级到7.x踩坑]]></title>
    <url>%2F2019%2F11%2F25%2Fbabel6%E5%8D%87%E7%BA%A7%E5%88%B07-x%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[babel官网babel-loader]]></content>
  </entry>
  <entry>
    <title><![CDATA[cookie篇]]></title>
    <url>%2F2019%2F11%2F21%2Fcookie%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是cookie? 第一次访问服务器的时候，会在响应头里面看到Set-Cookie信息（只有在首次访问服务器的时候才会在响应头中出现该信息）,如：Set-Cookie:JSESSIONID=joadjosd 浏览器会根据响应头的set-cookie信息设置浏览器的cookie并保存到浏览器本地 当再次请求的时候（非首次请求），浏览器会在请求头里将cookie发送给服务器(每次请求都是这样)，如：将上面保存的 JSESSIONID=joadjosd 发给服务器 什么是JSESSIONID？ 当用户访问服务器的时候，服务器会为每一个用户开启一个session,浏览器是怎么判断这个session到底是属于哪个用户呢？JSESSIONID的作用就体现出来了：JSESSIONID就是用来判断当前用户对应于哪个session，换句话说JSESSIONID会告诉服务器该浏览器的session保存在服务器内存的什么地方。 服务器首先检查这个浏览器的请求里是否已包含了一个session标识————称为session id，如果已包含则说明以前已经为此浏览器创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个）；如果浏览器请求不包含session id，则为此浏览器创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给浏览器保存。 保存这个session id的方式可以采用cookie，这样浏览器在下次请求中，会把包含这个session id的cookie发送给服务器。 一般这个cookie的名字都是类似于SESSIONID，JSESSIONID只是tomcat的对session id的叫法，其实就是session id，在其它的容器也许就不叫JSESSIONID了。 创建cookie123function setCookie(name,value,cookieDomain) &#123; document.cookie = name + '='+ encodeURIComponent(value) + ';domain=' + cookieDomain + ';path=/';&#125; 删除cookie1234567// 删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可function delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cookie = getCookie(name); cookie &amp;&amp; (document.cookie = name + '=' + cookie + ';expires=' + exp.toGMTString()); &#125; cookie属性 属性项 属性项介绍 NAME=VALUE 键值对，可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样 Expires 过期时间，在设置的某个时间点后该 Cookie 就会失效 Domain 生成该 Cookie 的域名，如 domain=”www.baidu.com&quot; Path 该 Cookie 是在当前的哪个路径下生成的，如 path=/wp-admin/ Secure 如果设置了这个属性，那么只会在 SSH 连接时才会回传该 Cookie 参考：1.JSESSIONID的简单说明2.cookie、session、sessionid 与jsessionid3.深入理解Cookie4.javascript cookie]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端js面试]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%89%8D%E7%AB%AFjs%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[判别Object跟Array12Object.prototype.toString.call([]); //"[object Array]"Object.prototype.toString.call(&#123;&#125;); //"[object Object]" 为什么不用typeof?12typeof [] //"object"typeof &#123;&#125; //"object" 5种基本数据类型ECMAScript中有5中简单数据类型（也称为基本数据类型）: Undefined、Null、Boolean、Number和String。还有1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。 this的绑定call和apply的区别 ，bind 深入理解this机制系列第一篇——this的4种绑定规则 2.事件委托事件流事件流:事件捕获阶段，处于目标阶段和事件冒泡阶段。事件捕获是从外层元素到目标元素的过程，事件冒泡是从目标元素到外层元素的过程。 事件委托原理事件委托的原理就是利用了事件冒泡，只需在DOM树中尽量最高的层次上添加一个事件处理程序，从而管理某一类型的所有事件。添加到页面上的事件处理程序的数量直接影响到页面的整体性能，原因： 1）每个函数都是对象，都会占用内存，内存中对象越多，性能就越差 2）事先绑定所有的事件处理程序而导致的DOM访问次数，也会延迟整个页面的交互就绪时间对“事件处理程序过多”问题的解决方案就是事件委托，因为只取得了一个DOM，只添加了一个事件处理程序，与普通方法相比，结果一样，但占用的内存更少。 ul绑定实例（1）ul li，怎样确定点击到li？e.target.nodeName dataset（2）li有很多子元素,子元素的点击是否会触发li的监听？e.target.closest（3）为什么不给每个button绑定事件或者说为什么事件委托性能最好？函数—对象—-内存被绑定的DOM访问次数多 严格模式和混杂模式严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码 Doctype不存在或者格式不正确会导致文档以混杂模式呈现。严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行；混杂模式是一种向后兼容的解析方法，可以实现IE5.5以下版本浏览器的渲染模式 媒体查询12&lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt;&lt;link rel="stylesheet" media="screen and (max-device-width:480px)" href="iphone.css" /&gt; 当屏幕在600px~900px之间时，body的背景色渲染为“#f5f5f5”，如下所示123456@media screen and (min-width:600px) and (max-width:900px)&#123; body &#123;background-color:#f5f5f5;&#125;&#125;@media screen and (orientation: landscape) &#123;// 竖屏&#125; script中的async defer： ajax12345678910111213141516171819//var xhr=new ActiveXObject()(IE5/IE6使用，现在基本不用)var xhr= new XMLHttpRequest(); // 新建XMLHttpRequest对象xhr.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (xhr.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (xhr.status === 200) &#123; // 成功 &#125; else &#123; // 失败 &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:xhr.open('GET', 'url'，'true（异步）或 false（同步）');xhr.send();]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面试是</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端css面试]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%89%8D%E7%AB%AFcss%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[css选择器!important &gt; 行内样式 &gt; id &gt; class &gt; tag 1.id选择器（ # myid）2.类选择器（.myclassname）3.标签选择器（div, h1, p）4.相邻选择器（h1 + p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（ * ）8.属性选择器（a[rel = “external”]）9.伪类选择器（a: hover, li:nth-child） 内联样式表的权值为 1000ID 选择器的权值为 100Class 类选择器的权值为 10HTML 标签选择器的权值为 1 盒子模型CSS3 box-sizing的作用:他的三个值content-box、inherit、border-box，改变盒模型的width BFC通俗的解释就是：1.内部的Box会在垂直方向上一个接一个的放置2.垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关。）3.每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）4.BFC的区域不会与float的元素区域重叠，计算BFC的高度时，浮动子元素也参与计算5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然 触发BFC：1.float的值不为none2.overflow的值不为visible3.display的值为inline-block、table-cell、table-caption4.position的值为absolute或fixed margin重叠 防止外边距重叠解决方案： 1.外层元素padding代替2.内层元素透明边框 border:1px solid transparent;3.内层元素padding:1px;4.触发BFC block、inline、inline-block的区别行内元素特征：(1)设置宽高无效 (2)对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间 (3)不会自动进行换行块状元素特征：(1)能够识别宽高 (2)margin和padding的上下左右均对其有效 (3)可以自动换行 (4)多个块状元素标签写在一起，默认排列方式为从上至下行内块状元素综合了行内元素和块状元素的特性，但是各有取舍。因此行内块状元素在日常的使用中，由于其特性，使用的次数也比较多。行内块状元素特征：(1)不自动换行 (2)能够识别宽高 (3)默认排列方式为从左到右]]></content>
  </entry>
  <entry>
    <title><![CDATA[npm和npx的区别]]></title>
    <url>%2F2019%2F03%2F08%2Fnpm%E5%92%8Cnpx%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[npmnpm是Node.js的软件包管理器，其目标是自动化的依赖性和软件包管理 npm 允许在package.json文件里面，使用scripts字段定义脚本命令 npxnpx是执行Node软件包的工具，它从 npm5.2版本开始，就与npm捆绑在一起。如果不能用，手动安装1npm install -g npx npm与npx执行命令对比： 12345678910111213// 免去了设置路径npx eslint --init// 若使用npm./node_modules/bin/eslint --init// 或者在package.json设置好scripts脚本 //&#123;// "scripts": &#123;// "eslint":"eslint --init"// &#125;//&#125; npm run eslint npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在 默认情况下，首先检查路径中是否存在要执行的包（即在项目中）； 如果存在，它将执行； 若不存在，意味着尚未安装该软件包，npx将安装其最新版本，然后执行它； 只执行，不安装(若未安装，会报错)1npx some-package --no-install]]></content>
      <categories>
        <category>node</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[各种安装]]></title>
    <url>%2F2018%2F12%2F29%2F%E5%90%84%E7%A7%8D%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[node 安装 去node官网，找到对应版本链接 wget https://nodejs.org/dist/v10.15.0/node-v10.15.0-linux-x64.tar.xz mv到对应目录，如/opt/ 解压 12tar -xvf node-v10.15.0-linux-x64.tar.xzmv node-v10.15.0-linux-x64.tar.xz nodejs 确认一下nodejs下bin目录是否有node 和npm文件，如果有则执行软连接，变为全局 12ln -s /opt/nodejs/bin/npm /usr/local/bin/ ln -s /opt/nodejs/bin/node /usr/local/bin/ git 安装ubuntu123456// 安装sudo apt-get install git// git仓库配置git config --global user.name "Your Name"git config --global user.email "email@example.com"]]></content>
  </entry>
  <entry>
    <title><![CDATA[缓存知识归纳]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[HTTP缓存机制 当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源： 200 from memory cache不访问服务器，直接读缓存，从内存中读取缓存,此时的数据时缓存到内存中的，当页面被关闭以后，数据将不存在。 200 from disk cache不访问服务器，直接读缓存，从磁盘中读取缓存，当页面或浏览器关闭后，数据还是存在。 304 (Not Modified) 缓存过期，但Last-Modified、Etag验证资源有效，服务器返回304 缓存需要强制验证，确定资源有效后，服务器返回304，如：Cache-Control：no-cach（这个设置规定缓存前必须先确定有效性） 具体描述： 本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器； 协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源； 缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本地缓存中没有找到资源)，服务器则返回该资源的数据，并且返回200 协商缓存阶段Last-Modified &amp; if-modified-since Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。last-modified是WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间。 ETag &amp; If-None-Match ETag与If-None-Match是一对报文，属于http 1.1。ETag是一个文件的唯一标志符,就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化,如果请求资源的ETag与服务器的不一致，则表示该资源已经被修改过来，需要发最新的内容给浏览器。 Etag/lastModified过程如下： 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个Last-Modified/ETag。 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。 注意：通过If-Modified-Since和If-Match判断资源是否修改，如未修改则返回304，发生了一次请求，但请求内容长度为0，节省了带宽，如果有多台负载均衡的服务器，不同服务器计算出的Etag可能不同，这样就会造成资源的重复加载。 Etag主要为了解决Last-Modified无法解决的一些问题： 一些文件如果改变后，又改回来了，Last-Modified会认为文件修改过，但其实它是没有变化的，Etag就不会判定它变化了 If-Modified-Since能检查到文件的变化是秒级别的，但如果一个文件1秒内变化了好几次，If-Modified-Since就检测不出来，这时需要Etag检测 某些服务器不能精确的得到文件的最后修改时间 本地缓存阶段Expires和Cache-Control是需要在服务器端配置的 Expires 指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires。如果expires到期需要重新请求。 Cache-Control Cache-Control:这个是http 1.1中为了弥补 Expires 缺陷新加入的，下面是常用的值： no-cache：强制浏览器在使用cache之前，先提交一个http请求到源服务器进行确认资源是否有效，防止从缓存中获取的是无效的资源。虽然http请求并未减少，但返回的是一个空的请求体，这样相当于减少了一个响应体。 no-store：no-store规定了浏览器不缓存任何缓存，而no-cache只是不缓存无效（这里是无效不是过期）的资源。如下图：资源Expires已失效，也设置了no-cach,但浏览器还是缓存了过期的资源(304可以证明已缓存)，因为服务器判断了If-Modified-Since，资源是没有改动过的，所以返回了304。 max-age:指定多少秒后缓存过期，如Cache-Control: max-age=3600, must-revalidate（3600秒后过期） must-revalidate: 强制浏览器严格遵守你设置的cache规则。 proxy-revalidate: 强制proxy严格遵守你设置的cache规则。 参考： 缓存策略 详解浏览器缓存机制与Apache设置缓存 由memoryCache和diskCache产生的浏览器缓存机制的思考]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack使用指南]]></title>
    <url>%2F2018%2F05%2F07%2Fwebpack%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[创建package.json1npm init 在项目的根目录中执行这个命令，它会自动创建 package.json文件，然后终端会问诸如项目名称，项目描述，作者等信息，可默认回车 安装Webpack依赖包1npm install --save-dev webpack 这时package.json里会增加两个属性：description和devDependencies –save-dev 与 –save的区别 npm install --save-dev *:使用此命令安装，会将依赖安装到devDependencies目录下，该目录下都是开发时需要的依赖,如npm install --save-dev gulp-uglify，安装了js的压缩包gulp-uglify，而压缩插件只在开发时使用，项目发布后不需要 npm install --save *:会将依赖安装到description目录下，该目录下都是发布后也需要的依赖，如vue这样的框架，项目发布后依然需要 简单的demo src/index.js 1document.getElementById('title').innerHTML = 'hello webpack'; dist/index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="title"&gt;&lt;/div&gt;&lt;script src="./js/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789// var path = require('path');module.exports = &#123; entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', // path: path.resolve(__dirname, 'dist'), filename: 'js/bundle.js' &#125;&#125; 注：__dirname是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 执行webpack，/dist/目录下会打包生成js/bundle.js,同时出现警告： 警告提示mode没有定义，这是 webpack 4x 引入的，有两个值，development 和 production，默认是production，可以用下面这两种方式指定： 执行webpack --mode development，而不是执行webpack 在webpack.config.js中指定mode属性，如：12345678module.exports = &#123; mode: 'development', entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', filename: 'js/bundle.js' &#125;&#125; 配置命令通过在package.json中配置script，如：123"scripts": &#123; "build": "webpack --mode development"&#125; 就可以用命令 npm run build 替代 webpack --mode development Source MapsSource Maps可以使调试更方便，当定位错误时，可以使编译文件与源文件一一对应，通过配置webpack.config.js中的devtool属性12345678module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', filename: 'js/bundle.js' &#125;&#125; devtool有4个值，优缺点如下： devtool选项 配置结果 source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度 cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便 eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项 cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点 使用webpack构建本地服务器Webpack提供了一个可选的本地开发服务器，可以让浏览器监听你的代码修改，并自动刷新显示修改后的结果这个本地服务器基于node.js构建，它是一个单独的组件，在webpack.config.js中配置前，需要单独安装 npm install --save-dev webpack-dev-server 然后配置devServer属性： 12345678910111213module.exports = &#123; entry: __dirname + '/src/index.js', output: &#123; path: __dirname + '/dist', filename: 'js/bundle.js' &#125;, devServer: &#123; contentBase: "./dist",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true,//实时刷新 port: 8080//设置默认监听端口，如果省略，默认为”8080“ &#125;&#125; 在package.json中的scripts对象中添加如下命令，用以开启本地服务器： 123"scripts": &#123; "server": "webpack-dev-server --open"&#125; 在终端中输入 npm run server即可在本地的8080端口查看结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[https原理]]></title>
    <url>%2F2018%2F05%2F03%2Fhttps%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[TCP/IP协议簇 TCP/IP协议簇是协议的集合，包含上图等协议，http协议就是它的一个子集；TCP/IP协议并不完全符合OSI的七层参考模型，它采用了4层的层级结构，如下图。 http协议处于应用层，当客户端发送http请求，为了便于传输，传输层（TCP协议）将应用层的http报文进行切割，并在各个报文上打上标记序号及端口号，转发给网络层（IP协议），网络层增加目的地——MAC地址后转发给链路层，这样发送网络的请求准备就齐全了；服务器端在链路层接收到数据，按顺序往上发送，一直到应用层，这样才算真正接收到http请求。 发送端在曾与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息，反之，服务器端在接收时会一层一层的去掉首部信息，这种把数据信息包装起来的方法叫做封装。 为了确认数据送到目标处，TCP协议采用了三次握手的策略，握手的过程中使用了TCP标志（flag）——SYN和ACK：发送端首先发送一个带有SYN的标志给对方，接收端收到后，发送一个SYN/ACK标志的数据包，表示确认收到，最后，发送端再发送一个ACK标志的数据包，代表“握手”结束。 http协议 HTTP协议（HyperText Transfer Protocol，超文本传输协议）：是客户端与Web服务器之间的应用层通信协议。 http协议的不足 通信使用明文（不加密），内容有可能被窃听 不验证通信双方的身份，有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 https协议 HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。 如上图，HTTPS 相比 HTTP 多了一层 SSL/TLS，位于应用层与TCP协议之间。 http请求劫持HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下： 加密算法 对称加密：加密和解密都是使用的同一个密钥——对称密钥。 非对称加密: 加密和解密使用不同的密钥——公钥、私钥，公钥和算法都是公开的，私钥是保密的，用公钥加密，就可以用私钥解密，反之亦然；但公钥是公开的（黑客也有公钥），如果私钥加密的信息被黑客截获，黑客同样可以使用公钥进行解密，获取其中的内容，所以使用非对称加密，通信双方通常有两套私钥和公钥，发消息的一方使用对方的公钥进行加密，接收消息的一方使用自己的私钥解密（所以私钥可以认为是个人身份的证明）；非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 消息摘要：消息摘要是哈希算法的一种，可以将消息哈希转换成一个固定长度的值唯一的字符串。值唯一的意思是不同的消息转换的摘要是不同的，并且能够确保唯一。该过程不可逆，即不能通过摘要反推明文（似乎SHA1已经可以被破解了，SHA2还没有。一般认为不可破解，或者破解需要耗费太多时间，性价比低）。 数字签名： 签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过;hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改,举例如下：假设现在有通信双方A和B，两者之间使用两套非对称加密机制,现在A向B发消息:那么，如果在发送过程中，有人修改了里面密文消息，B拿到的密文，解密之后得到明文，并非A所发送的，信息不正确。要解决两个问题：1. A的身份认证 2. A发送的消息完整性 那么就要用到上面所讲的基础知识。数字签名的过程如下图：简单解释：A：将明文进行摘要运算后得到摘要（消息完整性），再将摘要用A的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给B。B：收到A的消息后，先将密文用自己的私钥解密，得到明文。将数字签名用A的公钥进行解密后，得到正确的摘要（解密成功说明A的身份被认证了）。对明文进行摘要运算，得到实际收到的摘要，将两份摘要进行对比，如果一致，说明消息没有被篡改（消息完整性）。疑问：摘要使用A的私钥加密，如果被拥有A的公钥的第三者截获，不就可以获取到摘要了么，会不会对安全造成威胁？答：不会，因为摘要是不可逆推出原文的。 HTTP 向 HTTPS 演化使用对称加密若对传输的信息加密,这样即使黑客截获，也无法破解此种方式属于对称加密，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是： 因为双方都要有密钥，所以若是客户端有了一个密钥，如何安全地给服务器也传送一把 客户端、服务器数量多，安全级别也不同，密钥极易泄露 所以试一试非对称加密 使用非对称加密如上图所示，它只使用了一套公钥和私钥，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，同理，服务器使用私钥加密，客户端可以使用公钥解密，所以缺点就出来了：公钥是公开的（也就是黑客也会有公钥），所以第4步是不安全的，如果私钥加密的信息被黑客截获，黑客同样可以使用公钥进行解密，获取其中的内容。 但第3步是安全的，所以可以利用非对称加密的第3步，再结合对称加密的方式，一起实现加密。 对称与非对称加密的结合 第3步使用的是非对称加密，客户端用公钥加密，将对称加密算法和对称密钥传输给了服务器 服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥，这时客户端和服务器端都有了对称密钥 从第4步开始，双方都使用对称加密进行通信 这种方式的问题： 客户端如何获得公钥 如何确认服务器是真实的而不是黑客 所以有了数字证书，服务器需要申购SSL证书 SSL证书校验如上图所示，在第2步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有： 证书的发布机构CA 证书的有效期 公钥 证书所有者 签名… 客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下： 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验 浏览器的”证书管理器”，有”受信任的根证书颁发机构”列表,客户端会根据这张列表，比对服务器发来的证书中的颁发者CA，校验证书是否为合法机构颁发 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。 如果找到，那么浏览器就会从操作系统中取出颁发者CA的公钥，然后对服务器发来的证书里面的签名进行解密 浏览器使用相同的摘要算法计算出服务器发来的证书的摘要，将这个计算的摘要与证书签名解密出的摘要做对比 对比结果一致，则证明服务器发来的证书合法，没有被冒充 此时浏览器就可以读取证书中的公钥，用于后续加密了 所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成所以相比HTTP，HTTPS 传输更加安全 所有信息都是加密传播，黑客无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 总结综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。HTTPS 缺点： SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐 HTTPS 降低用户访问速度（多次握手） 网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转） HTTPS 涉及到的安全算法会消耗 CPU 本文转载自 HTTPS 加密算法原理详解，增加了少量自己的归纳、理解参考： 《图解HTTP协议》 数字签名原理简介]]></content>
  </entry>
  <entry>
    <title><![CDATA[毕设]]></title>
    <url>%2F2018%2F05%2F02%2F%E6%AF%95%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[跨平台应用技术研究 原生APP WebAPP HybirdAPP 用户体验 优异 差 良好 兼容性 优异 部分功能存在兼容性问题 部分功能存在兼容性问题 性能 优异 底层硬件能力弱 优异 更新 慢且需要审核 快且不需审核 快且不需审核 开发成本 高 低 低 HybirdAPP效果示例 使用JavaScript + html5 + css3 开发出的代码不仅可以运行在Android和IOS这样的移动平台，还可以运用于PC端的网页，但Hybrid APP在性能各方面都明显优于Web APP，所以本课题的系统最终选择使用Hbuilder来进行Hybrid开发。 AJAX12345678910111213141516171819//var xhr=new ActiveXObject()(IE5/IE6使用，现在基本不用)var xhr= new XMLHttpRequest(); // 新建XMLHttpRequest对象xhr.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (xhr.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (xhr.status === 200) &#123; // 成功 &#125; else &#123; // 失败 &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:xhr.open('GET', 'url'，'true（异步）或 false（同步）');xhr.send(); readyState状态码 readyState状态码分别代表的含义 0 (未初始化) 表示XMLHttpRequest对象已被创建，但还没有调用open()方法。 1 (载入) 表示已调用了open() 方法，但还未发送HTTP请求的状态。 2 (载入完成) 表示请求已经发送完成的状态。 3（交互） 表示正在接收数据响应的状态。 4 (交互完成) 表示数据已接收完成，且HTTP连接已关闭的状态。 HTTP协议、HTTPS协议https原理 JavaScript异步编程常见的4种异步编程方式 优点 缺点 回调函数 简单、易于部署 多个回调时会因层层嵌套变得复杂 事件监听 有利于去耦合，同时一个事件还可以绑定多个回调 程序的运行流程不按照书写的顺序 发布订阅 在事件监听的基础上增加了信号管理中心，是事件监听的改进版 ,使代码的运行流程易于观察 Promise 链式调用，解决层层嵌套的问题 Promise的使用对比不使用Promise：12345678910111213141516request('test1.html', '', function(data1) &#123; console.log('第一次请求成功, 这是返回的数据:', data1); request('test2.html', data1, function (data2) &#123; console.log('第二次请求成功, 这是返回的数据:', data2); request('test3.html', data2, function (data3) &#123; console.log('第三次请求成功, 这是返回的数据:', data3); //request... 继续请求 &#125;, function(error3) &#123; console.log('第三次请求失败, 这是失败信息:', error3); &#125;); &#125;, function(error2) &#123; console.log('第二次请求失败, 这是失败信息:', error2); &#125;);&#125;, function(error1) &#123; console.log('第一次请求失败, 这是失败信息:', error1);&#125;); 使用Promise：123456789sendRequest('test1.html', '').then(function(data1) &#123; console.log('第一次请求成功, 这是返回的数据:', data1);&#125;).then(function(data2) &#123; console.log('第二次请求成功, 这是返回的数据:', data2);&#125;).then(function(data3) &#123; console.log('第三次请求成功, 这是返回的数据:', data3);&#125;).catch(function(error) &#123; //用catch捕捉前面的错误 console.log('sorry, 请求失败了, 这是失败信息:', error);&#125;); Web断点续传技术和秒传技术断点续传是一个使用户在上传中途可以暂停的功能，它的底层依旧是通过HTTP请求来实现，但HTTP请求是不能暂停的，一次暂停中断就等于请求以失败而告终，所以断点续传是多次的HTTP请求，它先将被上传的文件进行分割，然后再一片一片的上传，最后在服务器端进行组合，具体原理如图2.2所示：在文件被切片以后，客户端会通过MD5加密函数对每一个切片进行标识，然后再上传到服务器，而服务器在接收文件以前，也会先对每个切片进行验证，若该切片的标识在服务器已存在，则表示它已上传过，若标识不存在，才会对该切片进行接收，并储存该标识，从而实现在暂停后续传的文件切片不被重复接收。以上就是断点续传的原理——上传文件前先将文件进行切片，然后通过标识来确认切片文件是否被上传过。而文件秒传技术的原理也和断点续传类似，只不过它是对整个文件进行标识，当服务器接收到已经存在的标识，就可判定正在上传的文件已被上传过，所以可以直接反馈给用户上传成功，从而实现秒传的功能。 浏览器缓存 移动端页面布局12&lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1, minimum-scale=1, user-scalable=no"&gt; 未设置布局的页面已设置过布局的页面宽高自适应 webpack1234// krpano中的动画tween(layer[funclayers].y,-60,0.5,linear,wait);tween(layer[thumbs].y,40,0.5,linear);set(layer[edit_back].visible,'false');]]></content>
  </entry>
</search>
